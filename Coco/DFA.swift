/*-------------------------------------------------------------------------
    DFA.swift -- Generation of the Scanner Automaton
    Compiler Generator Coco/R,
    Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
    extended by M. Loeberbauer & A. Woess, Univ. of Linz
    with improvements by Pat Terry, Rhodes University
    Swift port by Michael Griebling, 2015

    This program is free software; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2, or (at your option) any
    later version.

    This program is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.

    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc.,
    59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

    As an exception, it is allowed to write an extension of Coco/R that is
    used as a plugin in non-free software.

    If not otherwise stated, any source code generated by Coco/R (other than
    Coco/R itself) does not fall under the GNU General Public License.
-------------------------------------------------------------------------*/

import Foundation

//-----------------------------------------------------------------------------
//  State
//-----------------------------------------------------------------------------

open class State {				// state of finite automaton
    open var nr: Int = 0			// state number
    open var firstAction: Action? // to first action of this state
    open var endOf: Symbol? 		// recognized token if state is final
    open var ctx: Bool = false	// true if state is reached via contextTrans
    open var next: State?
    
    open func AddAction(_ act: Action) {
        var lasta: Action? = nil
        var a : Action? = firstAction
        while let an = a , act.typ >= an.typ { lasta = an; a = an.next }
        // collecting classes at the beginning gives better performance
        act.next = a
        if a === firstAction { firstAction = act } else { lasta!.next = act }
    }
    
    open func DetachAction(_ act: Action) {
        var lasta: Action? = nil
        var a : Action? = firstAction
        while let an = a , an !== act {lasta = an; a = an.next }
        if let an = a {
            if an === firstAction { firstAction = an.next } else { lasta!.next = an.next }
        }
    }
    
    open func MeltWith(_ s: State) { // copy actions of s to state
        var action = s.firstAction
        while action != nil {
            let a = Action(typ: action!.typ, sym: action!.sym, tc: action!.tc)
            a.AddTargets(action!)
            AddAction(a)
            action = action!.next
        }
    }
}


//-----------------------------------------------------------------------------
//  Action
//-----------------------------------------------------------------------------

open class Action {			// action of finite automaton
    open var typ: Int 		// type of action symbol: clas, chr
    open var sym: Int 		// action symbol
    open var tc: Int			// transition code: normalTrans, contextTrans
    open var target: Target? 	// states reached from this action
    open var next: Action?
    
    public init(typ: Int, sym: Int, tc:Int) {
        self.typ = typ; self.sym = sym; self.tc = tc
    }
    
    open func AddTarget(_ t: Target) { // add t to the action.targets
        var last: Target? = nil
        var p: Target? = target
        while let pn = p , t.state!.nr >= pn.state!.nr {
            if t.state === pn.state { return }
            last = pn; p = pn.next
        }
        t.next = p
        if p === target { target = t } else { last!.next = t }
    }
    
    open func AddTargets(_ a: Action) { // add copy of a.targets to action.targets
        var p = a.target
        while p != nil {
            let t = Target(s: p!.state!)
            AddTarget(t)
            p = p!.next
        }
        if a.tc == Node.contextTrans { tc = Node.contextTrans }
    }
    
    open func Symbols(_ tab: Tab) -> CharSet {
        var s: CharSet
        if typ == Node.clas {
            s = tab.CharClassSet(sym).Clone()
        } else {
            s = CharSet(); s.Set(sym)
        }
        return s
    }
    
    open func ShiftWith(_ s: CharSet, tab: Tab) {
        if s.Elements() == 1 {
            typ = Node.chr; sym = s.First()
        } else {
            var c = tab.FindCharClass(s)
            if c == nil { c = tab.NewCharClass("#", s) } // class with dummy name
            typ = Node.clas; sym = c!.n
        }
    }
}

//-----------------------------------------------------------------------------
//  Target
//-----------------------------------------------------------------------------

open class Target {				// set of states that are reached by an action
    open var state: State? 		// target state
    open var next: Target?
    
    public init (s: State) {
        state = s
    }
}

//-----------------------------------------------------------------------------
//  Melted
//-----------------------------------------------------------------------------

open class Melted {					// info about melted states
    open var set: BitArray 			// set of old states
    open var state: State? 			// new state
    open var next: Melted?
    
    public init(set: BitArray, state: State) {
        self.set = set; self.state = state
    }
}

//-----------------------------------------------------------------------------
//  Comment
//-----------------------------------------------------------------------------

open class Comment {					// info about comment syntax
    open var start: String
    open var stop: String
    open var nested: Bool
    open var next: Comment?
    
    public init(start:String, stop:String, nested:Bool) {
        self.start = start; self.stop = stop; self.nested = nested
    }
}

//-----------------------------------------------------------------------------
//  CharSet
//-----------------------------------------------------------------------------

open class CharSet {
    
    open class Range {
        open var from: Int
        open var to: Int
        open var next: Range?
        public init(from: Int, to:Int) { self.from = from; self.to = to }
    }
    
    open var head: Range?
    
    open subscript(i: Int) -> Bool {
        get {
            var p = head
            while p != nil {
                if i < p!.from { return false }
                else if i <= p!.to { return true } // p.from <= i <= p.to
                p = p!.next
            }
            return false
        }
    }
    
    open func Set(_ i: Int) {
        var cur = head
        var prev: Range? = nil
        while let ncur = cur , i >= ncur.from-1 {
            if i <= ncur.to + 1 { // (cur.from-1) <= i <= (cur.to+1)
                if i == ncur.from - 1 { ncur.from -= 1 }
                else if i == ncur.to + 1 {
                    ncur.to += 1
                    let next = ncur.next
                    if next != nil && ncur.to == next!.from - 1 { ncur.to = next!.to; ncur.next = next!.next }
                }
                return
            }
            prev = cur; cur = ncur.next
        }
        let n = Range(from: i, to: i)
        n.next = cur
        if prev == nil { head = n } else { prev!.next = n }
    }
    
    open func Clone() -> CharSet {
        let s = CharSet()
        var prev: Range? = nil
        var cur = head
        while cur != nil {
            let r = Range(from: cur!.from, to: cur!.to)
            if prev == nil { s.head = r } else { prev!.next = r }
            prev = r
            cur = cur!.next
        }
        return s
    }
    
    open func Equals(_ s: CharSet) -> Bool {
        var p = head
        var q = s.head
        while let pn = p, let qn = q {
            if pn.from != qn.from || pn.to != qn.to { return false }
            p = pn.next; q = qn.next
        }
        return p === q
    }
    
    open func Elements() -> Int {
        var n = 0
        var p = head
        while p != nil { n += p!.to - p!.from + 1;  p = p!.next }
        return n
    }
    
    open func First() -> Int {
        if let head = head { return head.from }
        return -1
    }
    
    open func Or(_ s: CharSet) {
        var p = s.head
        while p != nil {
            for i in p!.from...p!.to { Set(i) }
            p = p!.next
        }
    }
    
    open func And(_ s: CharSet) {
        let x = CharSet()
        var p = head
        while p != nil  {
            for i in p!.from...p!.to {
                if s[i] { x.Set(i) }
            }
            p = p!.next
        }
        head = x.head
    }
    
    open func Subtract(_ s: CharSet) {
        let x = CharSet()
        var p = head
        while p != nil {
            for i in p!.from...p!.to {
                if !s[i] { x.Set(i) }
            }
            p = p!.next
        }
        head = x.head;
    }
    
    open func Includes(_ s: CharSet) -> Bool {
        var p = s.head
        while p != nil  {
            for i in p!.from...p!.to {
                if !self[i] { return false }
            }
            p = p!.next
        }
        return true;
    }
    
    open func Intersects(_ s: CharSet) -> Bool {
        var p = s.head
        while p != nil {
            for i in p!.from...p!.to {
                if self[i] { return true }
            }
            p = p!.next
        }
        return false;
    }
    
    open func Fill() {
        head = Range(from: Int(unichar.min), to: Int(unichar.max))
    }
}

//-----------------------------------------------------------------------------
//  Generator
//-----------------------------------------------------------------------------
class Generator {
    fileprivate let EOF = -1
    
    fileprivate var fram: InputStream?
    fileprivate var gen: OutputStream?
    fileprivate let tab: Tab
    fileprivate var frameFile: String = ""
    
    init(tab: Tab) {
        self.tab = tab
    }
    
    func fileExists (_ name: String) -> Bool {
        let fileManager = FileManager.default
        return fileManager.fileExists(atPath: name)
    }
	
	func fileDelete (_ name: String) throws {
		let fileManager = FileManager.default
		try fileManager.removeItem(atPath: name)
	}
	
    func fileCopy (_ from: String, to: String) throws {
        let fileManager = FileManager.default
        try fileManager.copyItem(atPath: from, toPath: to)
    }
    
    func OpenFrame(_ frame: String) -> InputStream {
        if !tab.frameDir.isEmpty { frameFile = (tab.frameDir as NSString).appendingPathComponent(frame) }
        if frameFile.isEmpty || !fileExists(frameFile) { frameFile = (tab.srcDir as NSString).appendingPathComponent(frame) }
        if frameFile.isEmpty || !fileExists(frameFile) { assert(false, "Cannot find : " + frame) }
        
        let fram = InputStream(fileAtPath: frameFile)
		fram?.open()
        assert(fram != nil && fram!.hasBytesAvailable, "Cannot open frame file: " + frameFile)
        self.fram = fram!
        return fram!
    }
    
    func OpenGen(_ target: String) -> OutputStream? {
        let fn = (tab.outDir as NSString).appendingPathComponent(target)
        do {
            if fileExists(fn) {
				if fileExists(fn + ".old") { try fileDelete(fn + ".old") }
				try fileCopy(fn, to: fn + ".old")
			}
            gen = OutputStream(toFileAtPath: fn, append: false)
			gen?.open()
        } catch _ {
            assert(false, "Cannot generate file: " + fn)
        }
        return gen
    }
    
    func GenCopyright() {
        var copyFr = ""
        if !tab.frameDir.isEmpty { copyFr = (tab.frameDir as NSString).appendingPathComponent("Copyright.frame") }
        if copyFr.isEmpty || !fileExists(copyFr) { copyFr = (tab.srcDir as NSString).appendingPathComponent("Copyright.frame") }
        if copyFr.isEmpty || !fileExists(copyFr) { return }
        
        let scannerFram = fram
        if let lfram = InputStream(fileAtPath: copyFr) {
            fram = lfram
			fram?.open()
            CopyFramePart("")
            fram = scannerFram
        } else {
            assert(false, "Cannot open Copyright.frame")
        }
    }
    
    func SkipFramePart(_ stop: String) {
        CopyFramePart(stop, generateOutput: false)
    }
    
    func CopyFramePart(_ stop: String) {
        CopyFramePart(stop, generateOutput: true)
    }
    
    // if stop == nil, copies until end of file
    fileprivate func CopyFramePart(_ stop: String, generateOutput: Bool) {
        var startCh : Int = 0
        var endOfStopString = 0
        
        if !stop.isEmpty {
            startCh = stop[0].unicodeValue
            endOfStopString = stop.count() - 1
        }
        
        var ch = framRead()
        while ch != EOF {
            if !stop.isEmpty && ch == startCh {
                var i = 0
                repeat {
                    if i == endOfStopString { return } // stop[0..i] found
                    ch = framRead(); i += 1
                } while ch == stop[i].unicodeValue
                // stop[0..i-1] found; continue with last read character
                if generateOutput { gen!.Write((stop as NSString).substring(to: i)) }
            } else {
                if generateOutput { gen!.Write(String(Character(ch))) }
                ch = framRead()
            }
        }
        
        assert(stop.isEmpty, "Incomplete or corrupt frame file: " + frameFile)
    }
    
    fileprivate func framRead() -> Int {
        var buffer = [UInt8](repeating: 0, count: 4)
        if fram!.read(&buffer, maxLength: 1) == 1 {
            return Int(buffer[0])
        } else {
			return EOF
            // assert(false, "Error reading frame file: " + frameFile)
        }
    }
}

//-----------------------------------------------------------------------------
//  DFA
//-----------------------------------------------------------------------------

open class DFA {
    fileprivate var maxStates = 0
    fileprivate var lastStateNr: Int        // highest state number
    fileprivate var firstState: State?
    fileprivate var lastState: State?       // last allocated state
    fileprivate var lastSimState = 0        // last non melted state
	fileprivate var fram : InputStream?	// scanner frame input
	fileprivate var gen : OutputStream?	// generated scanner file
	fileprivate var curSy : Symbol?			// current token to be recognized (in FindTrans)
    fileprivate var dirtyDFA: Bool          // DFA may become nondeterministic in MatchLiteral
    
    open var ignoreCase: Bool         // true if input should be treated case-insensitively
    open var hasCtxMoves: Bool        // DFA has context transitions
    
    // other Coco objects
    fileprivate var parser: Parser
    fileprivate var tab: Tab
    fileprivate var errors: Errors
    fileprivate var trace: OutputStream
    
    public init (parser: Parser) {
        self.parser = parser
        tab = parser.tab
        errors = parser.errors
        trace = parser.trace!
        firstState = nil; lastState = nil; lastStateNr = -1
        firstMelted = nil; firstComment = nil
        ignoreCase = false
        dirtyDFA = false
        hasCtxMoves = false
        firstState = NewState()
    }
    
    //---------- Output primitives
    fileprivate func Ch(_ ch: Int) -> String {
        let lch = Character(ch)
        if lch == "\"" || lch == "\\" || lch ==  "\n" || lch ==  "\r" || lch ==  "\t" {
            return "\"" + tab.Escape(String(lch)) + "\""
        } else if lch < " " || ch >= 127 {
            return String(format: "\"\\u{0%X}\"", ch)
        } else { return "\"\(lch)\"" }
    }
    
    fileprivate func ChCond(_ ch: Character) -> String {
        return "ch == \(Ch(ch.unicodeValue))"
    }
    
    fileprivate func PutRange(_ s: CharSet) {
        var r = s.head
        while r != nil {
            if r!.from == r!.to { gen?.Write("ch == " + Ch(r!.from)) }
            else if r!.from == 0 { gen?.Write("ch <= " + Ch(r!.to)) }
            else { gen?.Write("ch >= " + Ch(r!.from) + " && ch <= " + Ch(r!.to)) }
            if r!.next != nil { gen?.Write(" || ") }
            r = r!.next
        }
    }
    
    //---------- State handling
    
    func NewState() -> State {
        let s = State(); lastStateNr += 1; s.nr = lastStateNr
        if firstState == nil { firstState = s } else { lastState!.next = s }
        lastState = s
        return s
    }
    
    func NewTransition(_ from: State, to: State, typ: Int, sym: Int, tc: Int) {
        let t = Target(s: to)
        let a = Action(typ: typ, sym: sym, tc: tc); a.target = t
        from.AddAction(a)
        if typ == Node.clas { curSy!.tokenKind = Symbol.classToken }
    }
    
    func CombineShifts() {
        var state: State?
        var a, b, c : Action?
        var seta: CharSet
        var setb: CharSet
        state = firstState
        while state != nil {
            a = state!.firstAction
            while a != nil {
                b = a!.next
                while b != nil {
                    if a!.target!.state === b!.target!.state && a!.tc == b!.tc {
                        seta = a!.Symbols(tab); setb = b!.Symbols(tab)
                        seta.Or(setb)
                        a!.ShiftWith(seta, tab: tab)
                        c = b; b = b!.next; state!.DetachAction(c!)
                    } else { b = b!.next }
                }
                a = a!.next
            }
            state = state!.next
        }
    }
    
    func FindUsedStates(_ state: State, used:BitArray) {
        if used[state.nr] { return }
        used[state.nr] = true
        var a = state.firstAction
        while a != nil {
            FindUsedStates(a!.target!.state!, used: used)
            a = a!.next
        }
    }
    
    func DeleteRedundantStates() {
        var newState = [State](repeating: State(), count: lastStateNr+1)
        let used = BitArray(lastStateNr+1)
        FindUsedStates(firstState!, used: used)
        // combine equal final states
        var s1 = firstState!.next
        while s1 != nil { // firstState cannot be final
            if used[s1!.nr] && s1!.endOf != nil && s1!.firstAction == nil && !s1!.ctx {
                var s2 = s1!.next
                while s2 != nil {
                    if used[s2!.nr] && s1!.endOf === s2!.endOf && s2!.firstAction == nil && !s2!.ctx {
                        used[s2!.nr] = false; newState[s2!.nr] = s1!
                    }
                    s2 = s2!.next
                }
            }
            s1 = s1!.next
        }
        var state = firstState
        while state != nil {
            if used[state!.nr] {
                var a = state!.firstAction
                while a != nil {
                    if !used[a!.target!.state!.nr] {
                        a!.target!.state = newState[a!.target!.state!.nr]
                    }
                    a = a!.next
                }
            }
            state = state!.next
        }
        
        // delete unused states
        lastState = firstState; lastStateNr = 0; // firstState has number 0
        var state2 = firstState!.next
        while state2 != nil {
            if used[state2!.nr] { lastStateNr += 1; state2!.nr = lastStateNr; lastState = state2 }
            else { lastState!.next = state2!.next }
            state2 = state2!.next
        }
    }
    
    func TheState(_ p: Node?) -> State {
        var state: State
        if p == nil { state = NewState(); state.endOf = curSy; return state }
        else { return p!.state! }
    }
    
    func Step(_ from: State, p: Node?, stepped: BitArray) {
        guard let p = p else { return }
        stepped[p.n] = true
        switch p.typ {
        case Node.clas, Node.chr:
            NewTransition(from, to: TheState(p.next), typ: p.typ, sym: p.val, tc: p.code)
        case Node.alt:
            Step(from, p: p.sub, stepped: stepped); Step(from, p: p.down, stepped: stepped)
        case Node.iter:
            if Tab.DelSubGraph(p.sub) {
                parser.SemErr("contents of {...} must not be deletable");
                return
            }
            if p.next != nil && !stepped[p.next!.n] { Step(from, p:p.next, stepped:stepped) }
            Step(from, p:p.sub, stepped: stepped)
            if p.state !== from {
                Step(p.state!, p:p, stepped:BitArray(tab.nodes.count))
            }
        case Node.opt:
            if (p.next != nil && !stepped[p.next!.n]) { Step(from, p:p.next, stepped:stepped) }
            Step(from, p:p.sub, stepped:stepped)
        default: break
        }
    }
    
    // Assigns a state n.state to every node n. There will be a transition from
    // n.state to n.next.state triggered by n.val. All nodes in an alternative
    // chain are represented by the same state.
    // Numbering scheme:
    //  - any node after a chr, clas, opt, or alt, must get a new number
    //  - if a nested structure starts with an iteration the iter node must get a new number
    //  - if an iteration follows an iteration, it must get a new number
    func NumberNodes(_ p: Node?, state: State?, renumIter: Bool) {
        var state = state
        guard let p = p else { return }
        if p.state != nil { return } // already visited;
        if state == nil || (p.typ == Node.iter && renumIter) { state = NewState() }
        p.state = state
        if Tab.DelGraph(p) { state!.endOf = curSy }
        switch p.typ {
        case Node.clas, Node.chr:
            NumberNodes(p.next, state: nil, renumIter: false)
        case Node.opt:
            NumberNodes(p.next, state: nil, renumIter: false)
            NumberNodes(p.sub, state: state, renumIter: true)
        case Node.iter:
            NumberNodes(p.next, state: state, renumIter: true)
            NumberNodes(p.sub, state: state, renumIter: true)
        case Node.alt:
            NumberNodes(p.next, state: nil, renumIter: false)
            NumberNodes(p.sub, state: state, renumIter: true)
            NumberNodes(p.down, state: state, renumIter: renumIter)
        default: break
        }
    }
    
    func FindTrans (_ p: Node?, start: Bool, marked: BitArray) {
        guard let p = p , !marked[p.n] else { return }
        marked[p.n] = true
        if start {
            Step(p.state!, p: p, stepped: BitArray(tab.nodes.count)) // start of group of equally numbered nodes
        }
        switch p.typ {
        case Node.clas, Node.chr:
            FindTrans(p.next, start: true, marked: marked)
        case Node.opt:
            FindTrans(p.next, start: true, marked: marked); FindTrans(p.sub, start: false, marked: marked)
        case Node.iter:
            FindTrans(p.next, start: false, marked: marked); FindTrans(p.sub, start: false, marked: marked)
        case Node.alt:
            FindTrans(p.sub, start: false, marked: marked); FindTrans(p.down, start: false, marked: marked)
        default: break
        }
    }
    
    open func ConvertToStates(_ p: Node, _ sym: Symbol) {
        curSy = sym;
        if Tab.DelGraph(p) {
            parser.SemErr("token might be empty")
            return
        }
        NumberNodes(p, state: firstState, renumIter: true)
        FindTrans(p, start: true, marked: BitArray(tab.nodes.count))
        if p.typ == Node.iter {
            Step(firstState!, p: p, stepped: BitArray(tab.nodes.count))
        }
    }
    
    // match string against current automaton; store it either as a fixedToken or as a litToken
    open func MatchLiteral(_ s: String, _ sym: Symbol) {
        var s = s
        s = tab.Unescape(s.substring(1, s.count()-2))
        let len = s.count()
        var state = firstState
        var a : Action? = nil
        var i: Int = 0
        while i < len { // try to match s against existing DFA
            a = FindAction(state!, ch: s[i])
            if a == nil { break }
            state = a!.target!.state
            i += 1
        }
        // if s was not totally consumed or leads to a non-final state => make new DFA from it
        if i != len || state!.endOf == nil {
            state = firstState; i = 0; a = nil
            dirtyDFA = true
        }
        while i < len { // make new DFA for s[i..len-1], ML: i is either 0 or len
            let to = NewState()
            NewTransition(state!, to: to, typ: Node.chr, sym: s[i].unicodeValue, tc: Node.normalTrans)
            state = to
            i += 1
        }
        let matchedSym = state!.endOf
        if state!.endOf == nil {
            state!.endOf = sym
        } else if matchedSym!.tokenKind == Symbol.fixedToken || (a != nil && a!.tc == Node.contextTrans) {
            // s matched a token with a fixed definition or a token with an appendix that will be cut off
            parser.SemErr("tokens " + sym.name + " and " + matchedSym!.name + " cannot be distinguished")
        } else { // matchedSym == classToken || classLitToken
            matchedSym!.tokenKind = Symbol.classLitToken
            sym.tokenKind = Symbol.litToken;
        }
    }
    
    func SplitActions(_ state: State, a: Action, b: Action) {
        var c: Action
        var setc: CharSet
        let seta = a.Symbols(tab)
        let setb = b.Symbols(tab)
        if seta.Equals(setb) {
            a.AddTargets(b)
            state.DetachAction(b)
        } else if seta.Includes(setb) {
            setc = seta.Clone(); setc.Subtract(setb)
            b.AddTargets(a)
            a.ShiftWith(setc, tab: tab)
        } else if setb.Includes(seta) {
            setc = setb.Clone(); setc.Subtract(seta)
            a.AddTargets(b)
            b.ShiftWith(setc, tab: tab)
        } else {
            setc = seta.Clone(); setc.And(setb)
            seta.Subtract(setc)
            setb.Subtract(setc)
            a.ShiftWith(seta, tab: tab)
            b.ShiftWith(setb, tab: tab)
            c = Action(typ: 0, sym: 0, tc: Node.normalTrans)  // typ and sym are set in ShiftWith
            c.AddTargets(a)
            c.AddTargets(b)
            c.ShiftWith(setc, tab: tab)
            state.AddAction(c)
        }
    }
    
    func Overlap(_ a: Action, b: Action) -> Bool {
        var seta, setb: CharSet
        if a.typ == Node.chr {
            if b.typ == Node.chr { return a.sym == b.sym }
            else { setb = tab.CharClassSet(b.sym); return setb[a.sym] }
        } else {
            seta = tab.CharClassSet(a.sym);
            if b.typ == Node.chr { return seta[b.sym] }
            else { setb = tab.CharClassSet(b.sym); return seta.Intersects(setb) }
        }
    }
    
    func MakeUnique(_ state: State) {
        var changed: Bool
        repeat {
            changed = false
            var a = state.firstAction
            while a != nil {
                var b = a!.next
                while b != nil {
                    if Overlap(a!, b: b!) { SplitActions(state, a: a!, b: b!); changed = true }
                     b = b!.next
                }
                a = a!.next
            }
        } while changed
    }
    
    func MeltStates(_ state: State) {
        var ctx = false
        var targets = BitArray()
		var endOf : Symbol?
        var action = state.firstAction
        while action != nil  {
            if action!.target!.next != nil {
                GetTargetStates(action!, targets: &targets, endOf: &endOf, ctx: &ctx)
                var melt = StateWithSet(targets)
                if melt == nil {
                    let s = NewState(); s.endOf = endOf; s.ctx = ctx
                    var targ = action!.target
                    while targ != nil {
                        s.MeltWith(targ!.state!)
                        targ = targ!.next
                    }
                    MakeUnique(s)
                    melt = NewMelted(targets, state: s)
                }
                action!.target!.next = nil
                action!.target!.state = melt!.state
            }
            action = action!.next
        }
    }
    
    func FindCtxStates() {
        var state = firstState
        while state != nil {
            var a = state!.firstAction
            while a != nil {
                if a!.tc == Node.contextTrans { a!.target!.state!.ctx = true }
                a = a!.next
            }
            state = state!.next
        }
    }
    
    open func MakeDeterministic() {
        var state: State?
        lastSimState = lastState!.nr
        maxStates = 2 * lastSimState // heuristic for set size in Melted.set
        FindCtxStates()
        state = firstState
        while state != nil {
            MakeUnique(state!)
            state = state!.next
        }
        state = firstState
        while state != nil {
            MeltStates(state!)
            state = state!.next
        }
        DeleteRedundantStates()
        CombineShifts()
    }

    open func PrintStates() {
        trace.WriteLine();
        trace.WriteLine("---------- states ----------")
        var state = firstState
        while state != nil  {
            var first = true
            if state!.endOf == nil { trace.Write("               ") }
            else { trace.Write("E(\(tab.Name(state!.endOf!.name)))") }
            trace.Write("\(state!.nr):")
            if state!.firstAction == nil { trace.WriteLine() }
            var action = state!.firstAction
            while action != nil {
                if first { trace.Write(" "); first = false } else { trace.Write("                    ") }
                if action!.typ == Node.clas { trace.Write((tab.classes[action!.sym]).name) }
                else { trace.Write("\(Ch(action!.sym))") }
                var targ = action!.target
                while targ != nil {
                    trace.Write(" \(targ!.state!.nr)")
                    targ = targ!.next
                }
                if action!.tc == Node.contextTrans { trace.WriteLine(" context") } else { trace.WriteLine() }
                action = action!.next
            }
            state = state!.next
        }
        trace.WriteLine();
        trace.WriteLine("---------- character classes ----------");
        tab.WriteCharClasses();
    }
    
    //---------------------------- actions --------------------------------
    
    open func FindAction(_ state: State, ch: Character) -> Action? {
        var a = state.firstAction
        while a != nil {
            if a!.typ == Node.chr && ch.unicodeValue == a!.sym { return a }
            else if a!.typ == Node.clas {
                let s = tab.CharClassSet(a!.sym)
                if s[ch.unicodeValue] { return a }
            }
            a = a!.next
        }
        return nil
    }
    
	open func GetTargetStates(_ a: Action, targets: inout BitArray, endOf: inout Symbol?, ctx: inout Bool) {
		// compute the set of target states
		targets = BitArray(maxStates); endOf = nil
		ctx = false
        var t = a.target
		while t != nil {
			let stateNr = t!.state!.nr
			if stateNr <= lastSimState { targets[stateNr] = true }
			else { targets.or(MeltedSet(stateNr)) }
			if t!.state!.endOf != nil {
				if endOf == nil || endOf === t!.state!.endOf {
					endOf = t!.state!.endOf
				} else {
					errors.SemErr("Tokens " + endOf!.name + " and " + t!.state!.endOf!.name + " cannot be distinguished")
				}
			}
			if t!.state!.ctx {
				ctx = true
				// The following check seems to be unnecessary. It reported an error
				// if a symbol + context was the prefix of another symbol, e.g.
				//   s1 = "a" "b" "c".
				//   s2 = "a" CONTEXT("b").
				// But this is ok.
				// if (t.state.endOf != nil) {
				//   Console.WriteLine("Ambiguous context clause");
				//	 errors.count++;
				// }
			}
            t = t!.next
		}
	}
	
    //------------------------- melted states ------------------------------
	
    var firstMelted: Melted?	// head of melted state list
	
    func NewMelted(_ set: BitArray, state: State) -> Melted {
        let m = Melted(set: set, state: state)
        m.next = firstMelted; firstMelted = m
        return m
    }
	
    func MeltedSet(_ nr: Int) -> BitArray {
        var m = firstMelted
        while m != nil {
            if m!.state!.nr == nr { return m!.set } else { m = m!.next }
        }
        assert(false, "compiler error in Melted.Set")
    }
    
    func StateWithSet(_ s: BitArray) -> Melted?  {
        var m = firstMelted
        while m != nil {
            if Sets.Equals(s, b: m!.set) { return m }
             m = m!.next
        }
        return nil
    }
    
    //------------------------ comments --------------------------------
    
    open var firstComment: Comment?	// list of comments
    
    func CommentStr(_ p: Node?) -> String {
        var p = p
        var s = ""
        while let np = p {
            if np.typ == Node.chr {
                s.append(Character(np.val))
            } else if np.typ == Node.clas {
                let set = tab.CharClassSet(np.val)
                if set.Elements() != 1 { parser.SemErr("character set contains more than 1 character") }
                s.append(Character(set.First()))
            } else { parser.SemErr("comment delimiters may not be structured") }
            p = np.next
        }
        if s.count() == 0 || s.count() > 2 {
            parser.SemErr("comment delimiters must be 1 or 2 characters long")
            s = "?"
        }
        return s
    }
    
    open func NewComment(_ from:Node, _ to: Node, _ nested: Bool) {
        let c = Comment(start: CommentStr(from), stop: CommentStr(to), nested: nested)
        c.next = firstComment; firstComment = c
    }
    
    
    //------------------------ scanner generation ----------------------
    
    func GenComBody(_ com: Comment) {
        gen?.WriteLine(  "\t\t\twhile true {")
        gen?.Write    (  "\t\t\t\tif \(ChCond(com.stop[0])) "); gen?.WriteLine("{")
        if com.stop.count() == 1 {
            gen?.WriteLine("\t\t\t\t\tlevel -= 1")
            gen?.WriteLine("\t\t\t\t\tif level == 0 { oldEols = line - line0; NextCh(); return true }")
            gen?.WriteLine("\t\t\t\t\tNextCh()")
        } else {
            gen?.WriteLine("\t\t\t\t\tNextCh()")
            gen?.WriteLine("\t\t\t\t\tif \(ChCond(com.stop[1])) {")
            gen?.WriteLine("\t\t\t\t\t\tlevel -= 1")
            gen?.WriteLine("\t\t\t\t\t\tif level == 0 { oldEols = line - line0; NextCh(); return true }")
            gen?.WriteLine("\t\t\t\t\t\tNextCh()")
            gen?.WriteLine("\t\t\t\t\t}")
        }
        if com.nested {
            gen?.Write    ("\t\t\t\t}"); gen?.Write(" else if \(ChCond(com.start[0])) "); gen?.WriteLine("{")
            if com.start.count() == 1 {
                gen?.WriteLine("\t\t\t\t\tlevel += 1; NextCh()")
            } else {
                gen?.WriteLine("\t\t\t\t\tNextCh()");
                gen?.Write    ("\t\t\t\t\tif \(ChCond(com.start[1])) "); gen?.WriteLine("{")
                gen?.WriteLine("\t\t\t\t\t\tlevel += 1; NextCh()")
                gen?.WriteLine("\t\t\t\t\t}")
            }
        }
        gen?.WriteLine(    "\t\t\t\t} else if ch == Character(Buffer.EOF) { return false }")
        gen?.WriteLine(    "\t\t\t\telse { NextCh() }")
        gen?.WriteLine(    "\t\t\t}")
    }
    
    func GenComment(_ com: Comment, i: Int) {
        gen?.WriteLine();
        gen?.Write    ("\tfunc Comment\(i)() -> Bool "); gen?.WriteLine("{");
        gen?.WriteLine("\t\tvar level = 1; let pos0 = pos; let line0 = line; let col0 = col; let charPos0 = charPos")
        if com.start.count() == 1 {
            gen?.WriteLine("\t\tNextCh()")
            GenComBody(com);
        } else {
            gen?.WriteLine("\t\tNextCh()");
            gen?.Write    ("\t\tif \(ChCond(com.start[1])) "); gen?.WriteLine("{")
            gen?.WriteLine("\t\t\tNextCh()")
            GenComBody(com)
            gen?.WriteLine("\t\t} else {")
            gen?.WriteLine("\t\t\tbuffer!.Pos = pos0; NextCh(); line = line0; col = col0; charPos = charPos0")
            gen?.WriteLine("\t\t}")
            gen?.WriteLine("\t\treturn false")
        }
        gen?.WriteLine("\t}")
    }
    
    func SymName(_ sym: Symbol) -> String {
        if sym.name[0].isLetter() { // real name value is stored in Tab.literals
            for e in tab.literals {
                if e.1 === sym { return e.0 }
            }
        }
        return sym.name
    }
    
    func GenLiterals () {
        if ignoreCase {
            gen?.WriteLine("\t\tswitch t.val.lowercased() {")
        } else {
            gen?.WriteLine("\t\tswitch t.val {")
        }
		for sym in tab.terminals + tab.pragmas {
            if sym.tokenKind == Symbol.litToken {
                var name = SymName(sym)
                if ignoreCase { name = name.lowercased() }
                // sym.name stores literals with quotes, e.g. "\"Literal\""
                gen?.WriteLine("\t\t\tcase \(name): t.kind = \(sym.n)")
            }
        }
        gen?.WriteLine("\t\t\tdefault: break")
        gen?.Write("\t\t}")
    }
    
    func WriteState(_ state: State) {
        let endOf = state.endOf
        gen?.WriteLine("\t\t\tcase \(state.nr):")
        if (endOf != nil && state.firstAction != nil) {
            gen?.WriteLine("\t\t\t\trecEnd = pos; recKind = \(endOf!.n)")
        }
        var ctxEnd = state.ctx
        var action = state.firstAction
        while action != nil {
            if action === state.firstAction { gen?.Write("\t\t\t\tif ") }
            else { gen?.Write("\t\t\t\telse if ") }
            if action!.typ == Node.chr { gen?.Write(ChCond(Character(action!.sym))) }
            else { PutRange(tab.CharClassSet(action!.sym)) }
            gen?.Write(" {")
            if action!.tc == Node.contextTrans {
                gen?.Write("apx += 1; "); ctxEnd = false
            } else if (state.ctx) {
                gen?.Write("apx = 0; ")
            }
            gen?.Write(" AddCh(); state = \(action!.target!.state!.nr) ")
            gen?.WriteLine("}")
            action = action!.next
        }
        if state.firstAction == nil {
            gen?.Write("\t\t\t\t")
        } else {
            gen?.Write("\t\t\t\telse {")
        }
        if ctxEnd { // final context state: cut appendix
            gen?.WriteLine()
            gen?.WriteLine("\t\t\t\t\ttlen -= apx")
            gen?.WriteLine("\t\t\t\t\tSetScannerBehindT()")
            gen?.Write("\t\t\t\t\t")
        }
        if endOf == nil {
            gen?.Write(" state = 0 ")
        } else {
            gen?.Write(" t.kind = \(endOf!.n); ")
            if endOf!.tokenKind == Symbol.classLitToken {
                gen?.Write(" t.val = tval; CheckLiteral(); return t ")
            } else {
                gen?.Write("break loop ")
            }
        }
        if state.firstAction != nil { gen?.Write("}") }
        gen?.WriteLine()
    }
    
    func WriteStartTab() {
        var action = firstState!.firstAction
        while action != nil {
            let targetState = action!.target!.state!.nr
            if action!.typ == Node.chr {
                gen?.WriteLine("\t\tresult[\(action!.sym)] = \(targetState)")
            } else {
                let s = tab.CharClassSet(action!.sym)
                var r = s.head
                while r != nil {
                    gen?.WriteLine("\t\tfor i in \(r!.from)...\(r!.to) { result[i] = \(targetState) }")
                    r = r!.next
                }
            }
            action = action!.next
        }
        gen?.WriteLine("\t\tresult[Buffer.EOF] = -1")
    }
    
    open func WriteScanner() {
        let g = Generator(tab: tab)
        fram = g.OpenFrame("Scanner.frame")
        gen = g.OpenGen("Scanner.swift")
        if dirtyDFA { MakeDeterministic() }
        
        g.GenCopyright()
        g.SkipFramePart("-->begin")
        
        g.CopyFramePart("-->namespace")
        if !tab.nsName.isEmpty {
            gen?.Write("namespace ")
            gen?.Write(tab.nsName)
            gen?.Write(" {")
        }
        g.CopyFramePart("-->declarations")
        gen?.WriteLine("\tlet maxT = \(tab.terminals.count - 1)")
        gen?.WriteLine("\tlet noSym = \(tab.noSym.n)")
        if ignoreCase {
            gen?.Write("\tvar valCh : Character = \"\\0\"  // current input character (for token.val)")
        }
        g.CopyFramePart("-->initialization")
        WriteStartTab();
        g.CopyFramePart("-->casing1")
        if ignoreCase {
            gen?.WriteLine("\t\tif ch != Character(Buffer.EOF) {")
            gen?.WriteLine("\t\t\tvalCh = ch")
            gen?.WriteLine("\t\t\tch = ch.lowercase")
            gen?.WriteLine("\t\t}")
        }
        g.CopyFramePart("-->casing2")
        gen?.Write("\t\t\ttval.append(")
        if ignoreCase { gen?.Write("valCh)") } else { gen?.Write("ch)") }
        g.CopyFramePart("-->comments")
        var com = firstComment
        var comIdx = 0
        while com != nil {
            GenComment(com!, i: comIdx)
            com = com!.next; comIdx += 1
        }
        g.CopyFramePart("-->literals"); GenLiterals()
        g.CopyFramePart("-->scan1")
        gen?.Write("\t\t\t")
        if tab.ignored.Elements() > 0 { PutRange(tab.ignored) } else { gen?.Write("false") }
        g.CopyFramePart("-->scan2")
        if (firstComment != nil) {
            gen?.Write("\t\tif ")
            com = firstComment; comIdx = 0
            while com != nil {
                gen?.Write(ChCond(com!.start[0]))
                gen?.Write(" && Comment\(comIdx)()")
                if com!.next != nil { gen?.Write(" || ") }
                com = com!.next; comIdx += 1
            }
            gen?.Write(" { return NextToken() }")
        }
        if hasCtxMoves { gen?.WriteLine(); gen?.Write("\t\tvar apx = 0") } /* pdt */
        g.CopyFramePart("-->scan3")
        var state = firstState!.next
        while state != nil {
            WriteState(state!)
            state = state!.next
        }
        g.CopyFramePart("")
        if !tab.nsName.isEmpty { gen?.Write("}") }
        gen?.close()
    }
    
} // end DFA

