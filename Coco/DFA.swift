/*-------------------------------------------------------------------------
    DFA.swift -- Generation of the Scanner Automaton
    Compiler Generator Coco/R,
    Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
    extended by M. Loeberbauer & A. Woess, Univ. of Linz
    with improvements by Pat Terry, Rhodes University
    Swift port by Michael Griebling, Computer Inspirations

    This program is free software; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2, or (at your option) any
    later version.

    This program is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.

    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc.,
    59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

    As an exception, it is allowed to write an extension of Coco/R that is
    used as a plugin in non-free software.

    If not otherwise stated, any source code generated by Coco/R (other than
    Coco/R itself) does not fall under the GNU General Public License.
-------------------------------------------------------------------------*/

import Foundation

//-----------------------------------------------------------------------------
//  State
//-----------------------------------------------------------------------------

public class State {				// state of finite automaton
    public var nr: Int = 0			// state number
    public var firstAction: Action? // to first action of this state
    public var endOf: Symbol? 		// recognized token if state is final
    public var ctx: Bool = false	// true if state is reached via contextTrans
    public var next: State?
    
    public func AddAction(act: Action) {
        var lasta: Action? = nil
        var a : Action? = firstAction
        while let an = a where act.typ >= an.typ { lasta = an; a = an.next }
        // collecting classes at the beginning gives better performance
        act.next = a
        if a === firstAction { firstAction = act } else { lasta!.next = act }
    }
    
    public func DetachAction(act: Action) {
        var lasta: Action? = nil
        var a : Action? = firstAction
        while let an = a where an !== act {lasta = an; a = an.next }
        if let an = a {
            if an === firstAction { firstAction = an.next } else { lasta!.next = an.next }
        }
    }
    
    public func MeltWith(s: State) { // copy actions of s to state
        for (var action = s.firstAction; action != nil; action = action!.next) {
            let a = Action(typ: action!.typ, sym: action!.sym, tc: action!.tc)
            a.AddTargets(action!)
            AddAction(a)
        }
    }
}


//-----------------------------------------------------------------------------
//  Action
//-----------------------------------------------------------------------------

public class Action {			// action of finite automaton
    public var typ: Int 		// type of action symbol: clas, chr
    public var sym: Int 		// action symbol
    public var tc: Int			// transition code: normalTrans, contextTrans
    public var target: Target? 	// states reached from this action
    public var next: Action?
    
    public init(typ: Int, sym: Int, tc:Int) {
        self.typ = typ; self.sym = sym; self.tc = tc
    }
    
    public func AddTarget(t: Target) { // add t to the action.targets
        var last: Target? = nil
        var p: Target? = target
        while let pn = p where t.state.nr >= pn.state.nr {
            if t.state === pn.state { return }
            last = pn; p = pn.next
        }
        t.next = p
        if p === target { target = t } else { last!.next = t }
    }
    
    public func AddTargets(a: Action) { // add copy of a.targets to action.targets
        for var p = a.target; p != nil; p = p!.next {
            let t = Target(s: p!.state)
            AddTarget(t)
        }
        if (a.tc == Node.contextTrans) { tc = Node.contextTrans }
    }
    
    public func Symbols(tab: Tab) -> CharSet {
        var s: CharSet
        if typ == Node.clas {
            s = tab.CharClassSet(sym)
        } else {
            s = CharSet(); s.Set(sym)
        }
        return s
    }
    
    public func ShiftWith(s: CharSet, tab: Tab) {
        if s.Elements() == 1 {
            typ = Node.chr; sym = s.First()
        } else {
            var c = tab.FindCharClass(s)
            if c == nil { c = tab.NewCharClass("#", s: s) } // class with dummy name
            typ = Node.clas; sym = c!.n
        }
    }
}

//-----------------------------------------------------------------------------
//  Target
//-----------------------------------------------------------------------------

public class Target {				// set of states that are reached by an action
    public var state: State 		// target state
    public var next: Target?
    
    public init (s: State) {
        state = s
    }
}

//-----------------------------------------------------------------------------
//  Melted
//-----------------------------------------------------------------------------

public class Melted {					// info about melted states
    public var set: BitArray 			// set of old states
    public var state: State 			// new state
    public var next: Melted?
    
    public init(set: BitArray, state: State) {
        self.set = set; self.state = state
    }
}

//-----------------------------------------------------------------------------
//  Comment
//-----------------------------------------------------------------------------

public class Comment {					// info about comment syntax
    public var start: String
    public var stop: String
    public var nested: Bool
    public var next: Comment?
    
    public init(start:String, stop:String, nested:Bool) {
        self.start = start; self.stop = stop; self.nested = nested
    }
}

//-----------------------------------------------------------------------------
//  CharSet
//-----------------------------------------------------------------------------

public class CharSet {
    
    public class Range {
        public var from: Int
        public var to: Int
        public var next: Range?
        public init(from: Int, to:Int) { self.from = from; self.to = to }
    }
    
    public var head: Range?
    
    public subscript(i: Int) -> Bool {
        get {
            for var p = head; p != nil; p = p!.next {
                if i < p!.from { return false }
                else if i <= p!.to { return true } // p.from <= i <= p.to
            }
            return false
        }
    }
    
    public func Set(i: Int) {
        var cur = head
        var prev: Range? = nil
        while let ncur = cur where i >= ncur.from-1 {
            if i <= ncur.to + 1 { // (cur.from-1) <= i <= (cur.to+1)
                if (i == ncur.from - 1) { ncur.from-- }
                else if (i == ncur.to + 1) {
                    ncur.to++
                    let next = ncur.next
                    if next != nil && ncur.to == next!.from - 1 { ncur.to = next!.to; ncur.next = next!.next }
                }
                return
            }
            prev = cur; cur = ncur.next
        }
        let n = Range(from: i, to: i)
        n.next = cur
        if prev == nil { head = n } else { prev!.next = n }
    }
    
    public func Clone() -> CharSet {
        let s = CharSet()
        var prev: Range? = nil
        for var cur = head; cur != nil; cur = cur!.next {
            let r = Range(from: cur!.from, to: cur!.to)
            if prev == nil { s.head = r } else { prev!.next = r }
            prev = r
        }
        return s
    }
    
    public func Equals(s: CharSet) -> Bool {
        var p = head
        var q = s.head
        while let pn = p, qn = q {
            if pn.from != qn.from || pn.to != qn.to { return false }
            p = pn.next; q = qn.next
        }
        return p === q
    }
    
    public func Elements() -> Int {
        var n = 0
        for var p = head; p != nil; p = p!.next { n += p!.to - p!.from + 1 }
        return n
    }
    
    public func First() -> Int {
        if let head = head { return head.from }
        return -1
    }
    
    public func Or(s: CharSet) {
        for var p = s.head; p != nil; p = p!.next {
            for i in p!.from...p!.to { Set(i) }
        }
    }
    
    public func And(s: CharSet) {
        let x = CharSet()
        for var p = head; p != nil; p = p!.next {
            for i in p!.from...p!.to {
                if s[i] { x.Set(i) }
            }
        }
        head = x.head
    }
    
    public func Subtract(s: CharSet) {
        let x = CharSet()
        for var p = head; p != nil; p = p!.next {
            for i in p!.from...p!.to {
                if !s[i] { x.Set(i) }
            }
        }
        head = x.head;
    }
    
    public func Includes(s: CharSet) -> Bool {
        for var p = s.head; p != nil; p = p!.next {
            for i in p!.from...p!.to {
                if !self[i] { return false }
            }
        }
        return true;
    }
    
    public func Intersects(s: CharSet) -> Bool {
        for var p = s.head; p != nil; p = p!.next {
            for i in p!.from...p!.to {
                if self[i] { return true }
            }
        }
        return false;
    }
    
    public func Fill() {
        head = Range(from: Int(unichar.min), to: Int(unichar.max))
    }
}

//-----------------------------------------------------------------------------
//  Generator
//-----------------------------------------------------------------------------
class Generator {
    private let EOF = -1
    
    private var fram: NSInputStream?
    private var gen: NSOutputStream?
    private let tab: Tab
    private var frameFile: String = ""
    
    init(tab: Tab) {
        self.tab = tab
    }
    
    func fileExists (name: String) -> Bool {
        let fileManager = NSFileManager.defaultManager()
        return fileManager.fileExistsAtPath(name)
    }
    
    func fileCopy (from: String, to: String) throws {
        let fileManager = NSFileManager.defaultManager()
        try fileManager.copyItemAtPath(from, toPath: to)
    }
    
    func OpenFrame(frame: String) -> NSInputStream {
        if !tab.frameDir.isEmpty { frameFile = (tab.frameDir as NSString).stringByAppendingPathComponent(frame) }
        if frameFile.isEmpty || !fileExists(frameFile) { frameFile = (tab.srcDir as NSString).stringByAppendingPathComponent(frame) }
        if frameFile.isEmpty || !fileExists(frameFile) { assert(false, "Cannot find : " + frame) }
        
        let fram = NSInputStream(fileAtPath: frameFile)
        assert(fram != nil && fram!.hasBytesAvailable, "Cannot open frame file: " + frameFile)
        self.fram = fram!
        return fram!
    }
    
    func OpenGen(target: String) -> NSOutputStream {
        let fn = (tab.outDir as NSString).stringByAppendingPathComponent(target)
        do {
            if fileExists(fn) { try fileCopy(fn, to: fn + ".old") }
            gen = NSOutputStream(toFileAtPath: fn, append: false)!
        } catch _ {
            assert(false, "Cannot generate file: " + fn)
        }
        return gen!
    }
    
    func GenCopyright() {
        var copyFr = ""
        if !tab.frameDir.isEmpty { copyFr = (tab.frameDir as NSString).stringByAppendingPathComponent("Copyright.frame") }
        if copyFr.isEmpty || !fileExists(copyFr) { copyFr = (tab.srcDir as NSString).stringByAppendingPathComponent("Copyright.frame") }
        if copyFr.isEmpty || !fileExists(copyFr) { return }
        
        let scannerFram = fram
        if let lfram = NSInputStream(fileAtPath: copyFr) {
            fram = lfram
            CopyFramePart("")
            fram = scannerFram
        } else {
            assert(false, "Cannot open Copyright.frame")
        }
    }
    
    func SkipFramePart(stop: String) {
        CopyFramePart(stop, generateOutput: false)
    }
    
    func CopyFramePart(stop: String) {
        CopyFramePart(stop, generateOutput: true)
    }
    
    // if stop == nil, copies until end of file
    private func CopyFramePart(stop: String, generateOutput: Bool) {
        var startCh : Int = 0
        var endOfStopString = 0
        
        if !stop.isEmpty {
            startCh = stop[0].unicodeValue()
            endOfStopString = stop.count() - 1
        }
        
        var ch = framRead()
        while ch != EOF {
            if !stop.isEmpty && ch == startCh {
                var i = 0
                repeat {
                    if i == endOfStopString { return } // stop[0..i] found
                    ch = framRead(); i++
                } while ch == stop[i].unicodeValue()
                // stop[0..i-1] found; continue with last read character
                if generateOutput { gen!.Write((stop as NSString).substringToIndex(i)) }
            } else {
                if generateOutput { gen!.Write(String(Character(ch))) }
                ch = framRead()
            }
        }
        
        assert(stop.isEmpty, "Incomplete or corrupt frame file: " + frameFile)
    }
    
    private func framRead() -> Int {
        var buffer = [UInt8](count: 4, repeatedValue: 0)
        if fram!.read(&buffer, maxLength: 1) == 1 {
            return Int(buffer[0])
        } else {
            assert(false, "Error reading frame file: " + frameFile)
        }
    }
}

//-----------------------------------------------------------------------------
//  DFA
//-----------------------------------------------------------------------------

public class DFA {
    private var maxStates = 0
    private var lastStateNr: Int        // highest state number
    private var firstState: State?
    private var lastState: State?       // last allocated state
    private var lastSimState = 0        // last non melted state
    private var fram = NSInputStream()  // scanner frame input
    private var gen = NSOutputStream()  // generated scanner file
    private var curSy = Symbol()        // current token to be recognized (in FindTrans)
    private var dirtyDFA: Bool          // DFA may become nondeterministic in MatchLiteral
    
    public var ignoreCase: Bool         // true if input should be treated case-insensitively
    public var hasCtxMoves: Bool        // DFA has context transitions
    
    // other Coco objects
    private var parser: Parser
    private var tab: Tab
    private var errors: Errors
    private var trace: NSOutputStream
    
    public init (parser: Parser) {
        self.parser = parser
        tab = parser.tab
        errors = parser.errors
        trace = parser.trace!
        firstState = nil; lastState = nil; lastStateNr = -1
        firstMelted = nil; firstComment = nil
        ignoreCase = false
        dirtyDFA = false
        hasCtxMoves = false
        firstState = NewState()
    }
    
    //---------- Output primitives
    private func Ch(ch: Int) -> String {
        let lch = Character(ch)
        if lch < " " || ch >= 127 || lch == "\'" || lch == "\\" { return String(ch) }
        else { return "\(lch)" }
    }
    
    private func ChCond(ch: Character) -> String {
        return "ch == \(ch)"
    }
    
    private func PutRange(s: CharSet) {
        for var r = s.head; r != nil; r = r!.next {
            if r!.from == r!.to { gen.Write("ch == " + Ch(r!.from)); }
            else if r!.from == 0 { gen.Write("ch <= " + Ch(r!.to)); }
            else { gen.Write("ch >= " + Ch(r!.from) + " && ch <= " + Ch(r!.to)) }
            if r!.next != nil { gen.Write(" || ") }
        }
    }
    
    //---------- State handling
    
    func NewState() -> State {
        let s = State(); s.nr = ++lastStateNr
        if firstState == nil { firstState = s } else { lastState!.next = s }
        lastState = s
        return s
    }
    
    func NewTransition(from: State, to: State, typ: Int, sym: Int, tc: Int) {
        let t = Target(s: to)
        let a = Action(typ: typ, sym: sym, tc: tc); a.target = t
        from.AddAction(a)
        if typ == Node.clas { curSy.tokenKind = Symbol.classToken }
    }
    
    func CombineShifts() {
        var state: State?
        var a, b, c : Action?
        var seta: CharSet
        var setb: CharSet
        for state = firstState; state != nil; state = state!.next {
            for a = state!.firstAction; a != nil; a = a!.next {
                b = a!.next
                while b != nil {
                    if a!.target!.state === b!.target!.state && a!.tc == b!.tc {
                        seta = a!.Symbols(tab); setb = b!.Symbols(tab)
                        seta.Or(setb)
                        a!.ShiftWith(seta, tab: tab)
                        c = b; b = b!.next; state!.DetachAction(c!)
                    } else { b = b!.next }
                }
            }
        }
    }
    
    func FindUsedStates(state: State, inout used:BitArray) {
        if used[state.nr] { return }
        used[state.nr] = true
        for var a = state.firstAction; a != nil; a = a!.next {
            FindUsedStates(a!.target!.state, used: &used)
        }
    }
    
    func DeleteRedundantStates() {
        var newState = [State](count: lastStateNr+1, repeatedValue: State())
        var used = BitArray(lastStateNr + 1)
        FindUsedStates(firstState!, used: &used)
        // combine equal final states
        for var s1 = firstState!.next; s1 != nil; s1 = s1!.next { // firstState cannot be final
            if used[s1!.nr] && s1!.endOf != nil && s1!.firstAction == nil && !s1!.ctx {
                for var s2 = s1!.next; s2 != nil; s2 = s2!.next {
                    if used[s2!.nr] && s1!.endOf === s2!.endOf && s2!.firstAction == nil && !s2!.ctx {
                        used[s2!.nr] = false; newState[s2!.nr] = s1!
                    }
                }
            }
        }
        for var state = firstState; state != nil; state = state!.next {
            if used[state!.nr] {
                for var a = state!.firstAction; a != nil; a = a!.next {
                    if !used[a!.target!.state.nr] {
                        a!.target!.state = newState[a!.target!.state.nr]
                    }
                }
            }
        }
        
        // delete unused states
        lastState = firstState; lastStateNr = 0; // firstState has number 0
        for var state = firstState!.next; state != nil; state = state!.next {
            if used[state!.nr] { state!.nr = ++lastStateNr; lastState = state }
            else { lastState!.next = state!.next }
        }
    }
    
    func TheState(p: Node?) -> State {
        var state: State
        if p == nil { state = NewState(); state.endOf = curSy; return state }
        else { return p!.state! }
    }
    
    func Step(from: State, p: Node?, inout stepped: BitArray) {
        guard let p = p else { return }
        stepped[p.n] = true
        switch p.typ {
        case Node.clas, Node.chr:
            NewTransition(from, to: TheState(p.next), typ: p.typ, sym: p.val, tc: p.code)
        case Node.alt:
            Step(from, p: p.sub, stepped: &stepped); Step(from, p: p.down, stepped: &stepped)
        case Node.iter:
            if Tab.DelSubGraph(p.sub) {
                parser.SemErr("contents of {...} must not be deletable");
                return
            }
            if p.next != nil && !stepped[p.next!.n] { Step(from, p:p.next, stepped:&stepped) }
            Step(from, p:p.sub, stepped: &stepped)
            if p.state !== from {
                stepped = BitArray( tab.nodes.count)
                Step(p.state!, p:p, stepped:&stepped)
            }
        case Node.opt:
            if (p.next != nil && !stepped[p.next!.n]) { Step(from, p:p.next, stepped:&stepped) }
            Step(from, p:p.sub, stepped:&stepped)
        default: break
        }
    }
    
    // Assigns a state n.state to every node n. There will be a transition from
    // n.state to n.next.state triggered by n.val. All nodes in an alternative
    // chain are represented by the same state.
    // Numbering scheme:
    //  - any node after a chr, clas, opt, or alt, must get a new number
    //  - if a nested structure starts with an iteration the iter node must get a new number
    //  - if an iteration follows an iteration, it must get a new number
    func NumberNodes(p: Node?, var state: State?, renumIter: Bool) {
        guard let p = p else { return }
        if p.state != nil { return } // already visited;
        if state == nil || (p.typ == Node.iter && renumIter) { state = NewState() }
        p.state = state
        if Tab.DelGraph(p) { state!.endOf = curSy }
        switch p.typ {
        case Node.clas, Node.chr:
            NumberNodes(p.next, state: nil, renumIter: false)
        case Node.opt:
            NumberNodes(p.next, state: nil, renumIter: false)
            NumberNodes(p.sub, state: state, renumIter: true)
        case Node.iter:
            NumberNodes(p.next, state: state, renumIter: true)
            NumberNodes(p.sub, state: state, renumIter: true)
        case Node.alt:
            NumberNodes(p.next, state: nil, renumIter: false)
            NumberNodes(p.sub, state: state, renumIter: true)
            NumberNodes(p.down, state: state, renumIter: renumIter)
        default: break
        }
    }
    
    func FindTrans (p: Node?, start: Bool, inout marked: BitArray) {
        guard let p = p else { return }
        if marked[p.n] { return }
        marked[p.n] = true
        if start {
			var steps = BitArray( tab.nodes.count)
            Step(p.state!, p: p, stepped: &steps) // start of group of equally numbered nodes
        }
        switch p.typ {
        case Node.clas, Node.chr:
            FindTrans(p.next, start: true, marked: &marked)
        case Node.opt:
            FindTrans(p.next, start: true, marked: &marked); FindTrans(p.sub, start: false, marked: &marked)
        case Node.iter:
            FindTrans(p.next, start: false, marked: &marked); FindTrans(p.sub, start: false, marked: &marked)
        case Node.alt:
            FindTrans(p.sub, start: false, marked: &marked); FindTrans(p.down, start: false, marked: &marked)
        default: break
        }
    }
    
    public func ConvertToStates(p: Node, sym: Symbol) {
        curSy = sym;
        if Tab.DelGraph(p) {
            parser.SemErr("token might be empty")
            return
        }
        NumberNodes(p, state: firstState, renumIter: true)
		var trans = BitArray(tab.nodes.count)
        FindTrans(p, start: true, marked: &trans)
        if p.typ == Node.iter {
			var steps = BitArray(tab.nodes.count)
            Step(firstState!, p: p, stepped: &steps)
        }
    }
    
    // match string against current automaton; store it either as a fixedToken or as a litToken
    public func MatchLiteral(var s: String, _ sym: Symbol) {
        s = tab.Unescape(s.substring(1, s.count()-2))
        let len = s.count()
        var state = firstState
        var a : Action? = nil
        var i: Int
        for i=0;i<len;i++ { // try to match s against existing DFA
            a = FindAction(state!, ch: s[i])
            if (a == nil) { break }
            state = a!.target!.state
        }
        // if s was not totally consumed or leads to a non-final state => make new DFA from it
        if i != len || state!.endOf == nil {
            state = firstState; i = 0; a = nil
            dirtyDFA = true
        }
        for ; i < len; i++ { // make new DFA for s[i..len-1], ML: i is either 0 or len
            let to = NewState()
            NewTransition(state!, to: to, typ: Node.chr, sym: s[i].unicodeValue(), tc: Node.normalTrans)
            state = to
        }
        let matchedSym = state!.endOf
        if state!.endOf == nil {
            state!.endOf = sym
        } else if matchedSym!.tokenKind == Symbol.fixedToken || (a != nil && a!.tc == Node.contextTrans) {
            // s matched a token with a fixed definition or a token with an appendix that will be cut off
            parser.SemErr("tokens " + sym.name + " and " + matchedSym!.name + " cannot be distinguished")
        } else { // matchedSym == classToken || classLitToken
            matchedSym!.tokenKind = Symbol.classLitToken
            sym.tokenKind = Symbol.litToken;
        }
    }
    
    func SplitActions(state: State, a: Action, b: Action) {
        var c: Action
        var setc: CharSet
        let seta = a.Symbols(tab)
        let setb = b.Symbols(tab)
        if seta.Equals(setb) {
            a.AddTargets(b)
            state.DetachAction(b)
        } else if seta.Includes(setb) {
            setc = seta.Clone(); setc.Subtract(setb)
            b.AddTargets(a)
            a.ShiftWith(setc, tab: tab)
        } else if setb.Includes(seta) {
            setc = setb.Clone(); setc.Subtract(seta)
            a.AddTargets(b)
            b.ShiftWith(setc, tab: tab);
        } else {
            setc = seta.Clone(); setc.And(setb);
            seta.Subtract(setc);
            setb.Subtract(setc);
            a.ShiftWith(seta, tab: tab);
            b.ShiftWith(setb, tab: tab);
            c = Action(typ: 0, sym: 0, tc: Node.normalTrans)  // typ and sym are set in ShiftWith
            c.AddTargets(a);
            c.AddTargets(b);
            c.ShiftWith(setc, tab: tab);
            state.AddAction(c);
        }
    }
    
    func Overlap(a: Action, b: Action) -> Bool {
        var seta, setb: CharSet
        if a.typ == Node.chr {
            if b.typ == Node.chr { return a.sym == b.sym }
            else { setb = tab.CharClassSet(b.sym); return setb[a.sym] }
        } else {
            seta = tab.CharClassSet(a.sym);
            if (b.typ == Node.chr) { return seta[b.sym] }
            else { setb = tab.CharClassSet(b.sym); return seta.Intersects(setb) }
        }
    }
    
    func MakeUnique(state: State) {
        var changed: Bool
        repeat {
            changed = false
            for var a = state.firstAction; a != nil; a = a!.next {
                for var b = a!.next; b != nil; b = b!.next {
                    if Overlap(a!, b: b!) { SplitActions(state, a: a!, b: b!); changed = true }
                }
            }
        } while changed
    }
    
    func MeltStates(state: State) {
        var ctx = false
        var targets = BitArray()
        var endOf: Symbol?
        for var action = state.firstAction; action != nil; action = action!.next {
            if action!.target!.next != nil {
                GetTargetStates(action!, targets: &targets, endOf: &endOf, ctx: &ctx)
                var melt = StateWithSet(targets)
                if melt == nil {
                    let s = NewState(); s.endOf = endOf; s.ctx = ctx
                    for var targ = action!.target; targ != nil; targ = targ!.next {
                        s.MeltWith(targ!.state)
                    }
                    MakeUnique(s)
                    melt = NewMelted(targets, state: s)
                }
                action!.target!.next = nil
                action!.target!.state = melt!.state
            }
        }
    }
    
    func FindCtxStates() {
        for var state = firstState; state != nil; state = state!.next {
            for var a = state!.firstAction; a != nil; a = a!.next {
                if a!.tc == Node.contextTrans { a!.target!.state.ctx = true }
            }
        }
    }
    
    public func MakeDeterministic() {
        var state: State?
        lastSimState = lastState!.nr
        maxStates = 2 * lastSimState // heuristic for set size in Melted.set
        FindCtxStates()
        for state = firstState; state != nil; state = state!.next {
            MakeUnique(state!)
        }
        for state = firstState; state != nil; state = state!.next {
            MeltStates(state!)
        }
        DeleteRedundantStates()
        CombineShifts()
    }

    public func PrintStates() {
        trace.WriteLine();
        trace.WriteLine("---------- states ----------");
        for var state = firstState; state != nil; state = state!.next {
            var first = true
            if state!.endOf == nil { trace.Write("               ") }
            else { trace.Write("E(\(tab.Name(state!.endOf!.name)))") }
            trace.Write("\(state!.nr):")
            if state!.firstAction == nil { trace.WriteLine() }
            for var action = state!.firstAction; action != nil; action = action!.next {
                if first { trace.Write(" "); first = false } else { trace.Write("                    ") }
                if action!.typ == Node.clas { trace.Write((tab.classes[action!.sym]).name) }
                else { trace.Write("\(Ch(action!.sym))") }
                for var targ = action!.target; targ != nil; targ = targ!.next {
                    trace.Write(" \(targ!.state.nr)")
                }
                if action!.tc == Node.contextTrans { trace.WriteLine(" context") } else { trace.WriteLine() }
            }
        }
        trace.WriteLine();
        trace.WriteLine("---------- character classes ----------");
        tab.WriteCharClasses();
    }
    
    //---------------------------- actions --------------------------------
    
    public func FindAction(state: State, ch: Character) -> Action? {
        for var a = state.firstAction; a != nil; a = a!.next {
            if a!.typ == Node.chr && ch.unicodeValue() == a!.sym { return a }
            else if a!.typ == Node.clas {
                let s = tab.CharClassSet(a!.sym)
                if s[ch.unicodeValue()] { return a }
            }
        }
        return nil
    }
    
    public func GetTargetStates(a: Action, inout targets: BitArray, inout endOf: Symbol?, inout ctx: Bool) {
        // compute the set of target states
        targets = BitArray(maxStates); endOf = nil
        ctx = false
        for var t = a.target; t != nil; t = t!.next {
            let stateNr = t!.state.nr
            if stateNr <= lastSimState { targets[stateNr] = true }
            else { targets.or(MeltedSet(stateNr)) }
            if t!.state.endOf != nil {
                if endOf == nil || endOf === t!.state.endOf {
                    endOf = t!.state.endOf
                } else {
                    errors.SemErr("Tokens " + endOf!.name + " and " + t!.state.endOf!.name + " cannot be distinguished")
                }
                if t!.state.ctx {
                    ctx = true
                    // The following check seems to be unnecessary. It reported an error
                    // if a symbol + context was the prefix of another symbol, e.g.
                    //   s1 = "a" "b" "c".
                    //   s2 = "a" CONTEXT("b").
                    // But this is ok.
                    // if (t.state.endOf != nil) {
                    //   Console.WriteLine("Ambiguous context clause");
                    //	 errors.count++;
                    // }
                }
            }
        }
    }
    
    //------------------------- melted states ------------------------------
    
    var firstMelted: Melted?	// head of melted state list
    
    func NewMelted(set: BitArray, state: State) -> Melted {
        let m = Melted(set: set, state: state)
        m.next = firstMelted; firstMelted = m
        return m
    }
    
    func MeltedSet(nr: Int) -> BitArray {
        var m = firstMelted
        while m != nil {
            if m!.state.nr == nr { return m!.set } else { m = m!.next }
        }
        assert(false, "compiler error in Melted.Set")
    }
    
    func StateWithSet(s: BitArray) -> Melted?  {
        for var m = firstMelted; m != nil; m = m!.next {
            if Sets.Equals(s, b: m!.set) { return m }
        }
        return nil
    }
    
    //------------------------ comments --------------------------------
    
    public var firstComment: Comment?	// list of comments
    
    func CommentStr(var p: Node?) -> String {
        var s = ""
        while let np = p {
            if np.typ == Node.chr {
                s.append(Character(np.val))
            } else if np.typ == Node.clas {
                let set = tab.CharClassSet(np.val)
                if set.Elements() != 1 { parser.SemErr("character set contains more than 1 character") }
                s.append(Character(set.First()))
            } else { parser.SemErr("comment delimiters may not be structured") }
            p = np.next
        }
        if s.count() == 0 || s.count() > 2 {
            parser.SemErr("comment delimiters must be 1 or 2 characters long")
            s = "?"
        }
        return s
    }
    
    public func NewComment(from:Node, to: Node, nested: Bool) {
        let c = Comment(start: CommentStr(from), stop: CommentStr(to), nested: nested)
        c.next = firstComment; firstComment = c
    }
    
    
    //------------------------ scanner generation ----------------------
    
    func GenComBody(com: Comment) {
        gen.WriteLine(  "\t\t\tfor (;;) {")
        gen.Write    (  "\t\t\t\tif \(ChCond(com.stop[0])) "); gen.WriteLine("{")
        if com.stop.count() == 1 {
            gen.WriteLine("\t\t\t\t\tlevel--")
            gen.WriteLine("\t\t\t\t\tif level == 0 { oldEols = line - line0; NextCh(); return true }")
            gen.WriteLine("\t\t\t\t\tNextCh()")
        } else {
            gen.WriteLine("\t\t\t\t\tNextCh()")
            gen.WriteLine("\t\t\t\t\tif \(ChCond(com.stop[1])) {{")
            gen.WriteLine("\t\t\t\t\t\tlevel--;");
            gen.WriteLine("\t\t\t\t\t\tif level == 0 { oldEols = line - line0; NextCh(); return true }")
            gen.WriteLine("\t\t\t\t\t\tNextCh()")
            gen.WriteLine("\t\t\t\t\t}")
        }
        if com.nested {
            gen.Write    ("\t\t\t\t}"); gen.Write(" else if \(ChCond(com.start[0])) "); gen.WriteLine("{")
            if com.start.count() == 1 {
                gen.WriteLine("\t\t\t\t\tlevel++; NextCh()")
            } else {
                gen.WriteLine("\t\t\t\t\tNextCh()");
                gen.Write    ("\t\t\t\t\tif \(ChCond(com.start[1])) "); gen.WriteLine("{")
                gen.WriteLine("\t\t\t\t\t\tlevel++; NextCh()")
                gen.WriteLine("\t\t\t\t\t}")
            }
        }
        gen.WriteLine(    "\t\t\t\t} else if ch == Buffer.EOF { return false }")
        gen.WriteLine(    "\t\t\t\telse { NextCh() }")
        gen.WriteLine(    "\t\t\t}")
    }
    
    func GenComment(com: Comment, i: Int) {
        gen.WriteLine();
        gen.Write    ("\tfunc Comment\(i)() -> Bool "); gen.WriteLine("{");
        gen.WriteLine("\t\tvar level = 1; var pos0 = pos; var line0 = line, var col0 = col; var charPos0 = charPos")
        if com.start.count() == 1 {
            gen.WriteLine("\t\tNextCh()")
            GenComBody(com);
        } else {
            gen.WriteLine("\t\tNextCh()");
            gen.Write    ("\t\tif \(ChCond(com.start[1])) "); gen.WriteLine("{")
            gen.WriteLine("\t\t\tNextCh()")
            GenComBody(com)
            gen.WriteLine("\t\t} else {")
            gen.WriteLine("\t\t\tbuffer.Pos = pos0; NextCh(); line = line0; col = col0; charPos = charPos0")
            gen.WriteLine("\t\t}")
            gen.WriteLine("\t\treturn false")
        }
        gen.WriteLine("\t}")
    }
    
    func SymName(sym: Symbol) -> String {
        if sym.name[0].isLetter() { // real name value is stored in Tab.literals
            for e in tab.literals {
                if e.1 === sym { return e.0 }
            }
        }
        return sym.name
    }
    
    func GenLiterals () {
        if ignoreCase {
            gen.WriteLine("\t\tswitch t.val.lowercaseString {")
        } else {
            gen.WriteLine("\t\tswitch t.val {")
        }
        for sym in tab.terminals + tab.pragmas {
            if sym.tokenKind == Symbol.litToken {
                var name = SymName(sym)
                if ignoreCase { name = name.lowercaseString }
                // sym.name stores literals with quotes, e.g. "\"Literal\""
                gen.WriteLine("\t\t\tcase \(name): t.kind = \(sym.n)")
            }
        }
        gen.WriteLine("\t\t\tdefault: break")
        gen.Write("\t\t}")
    }
    
    func WriteState(state: State) {
        let endOf = state.endOf
        gen.WriteLine("\t\t\tcase \(state.nr):")
        if (endOf != nil && state.firstAction != nil) {
            gen.WriteLine("\t\t\t\trecEnd = pos; recKind = \(endOf!.n)")
        }
        var ctxEnd = state.ctx
        for var action = state.firstAction; action != nil; action = action!.next {
            if action === state.firstAction { gen.Write("\t\t\t\tif ") }
            else { gen.Write("\t\t\t\telse if ") }
            if action!.typ == Node.chr { gen.Write(ChCond(Character(action!.sym))) }
            else { PutRange(tab.CharClassSet(action!.sym)) }
            gen.Write(" {")
            if action!.tc == Node.contextTrans {
                gen.Write("apx++; "); ctxEnd = false
            } else if (state.ctx) {
                gen.Write("apx = 0; ")
            }
            gen.Write("AddCh(); goto case \(action!.target!.state.nr)")
            gen.WriteLine("}")
        }
        if state.firstAction == nil {
            gen.Write("\t\t\t\t{");
        } else {
            gen.Write("\t\t\t\telse {")
        }
        if ctxEnd { // final context state: cut appendix
            gen.WriteLine()
            gen.WriteLine("\t\t\t\t\ttlen -= apx")
            gen.WriteLine("\t\t\t\t\tSetScannerBehindT()")
            gen.Write("\t\t\t\t\t")
        }
        if endOf == nil {
            gen.WriteLine("goto case 0 }")
        } else {
            gen.Write("t.kind = \(endOf!.n) ")
            if endOf!.tokenKind == Symbol.classLitToken {
                gen.WriteLine("t.val = String(tval, 0, tlen); CheckLiteral(); return t }")
            } else {
                gen.WriteLine("break }")
            }
        }
    }
    
    func WriteStartTab() {
        for var action = firstState!.firstAction; action != nil; action = action!.next {
            let targetState = action!.target!.state.nr
            if action!.typ == Node.chr {
                gen.WriteLine("\t\tstart[\(action!.sym)] = \(targetState)")
            } else {
                let s = tab.CharClassSet(action!.sym)
                for var r = s.head; r != nil; r = r!.next {
                    gen.WriteLine("\t\tfor i in \(r!.from)...\(r!.to) { start[i] = \(targetState) }")
                }
            }
        }
        gen.WriteLine("\t\tstart[Buffer.EOF] = -1")
    }
    
    public func WriteScanner() {
        let g = Generator(tab: tab)
        fram = g.OpenFrame("Scanner.frame")
        gen = g.OpenGen("Scanner.cs")
        if dirtyDFA { MakeDeterministic() }
        
        g.GenCopyright()
        g.SkipFramePart("-->begin")
        
        g.CopyFramePart("-->namespace")
        if !tab.nsName.isEmpty {
            gen.Write("namespace ")
            gen.Write(tab.nsName)
            gen.Write(" {")
        }
        g.CopyFramePart("-->declarations")
        gen.WriteLine("\tlet maxT = \(tab.terminals.count - 1)")
        gen.WriteLine("\tlet noSym = \(tab.noSym.n)")
        if ignoreCase {
            gen.Write("\tvar valCh : Character       // current input character (for token.val)")
        }
        g.CopyFramePart("-->initialization")
        WriteStartTab();
        g.CopyFramePart("-->casing1")
        if ignoreCase {
            gen.WriteLine("\t\tif ch != Buffer.EOF {")
            gen.WriteLine("\t\t\tvalCh = Character(ch)")
            gen.WriteLine("\t\t\tch = Character(ch).lowercase")
            gen.WriteLine("\t\t}")
        }
        g.CopyFramePart("-->casing2")
        gen.Write("\t\t\ttval[tlen++] = ")
        if ignoreCase { gen.Write("valCh") } else { gen.Write("Character(ch)") }
        g.CopyFramePart("-->comments")
        var com = firstComment
        var comIdx = 0
        while com != nil {
            GenComment(com!, i: comIdx)
            com = com!.next; comIdx++
        }
        g.CopyFramePart("-->literals"); GenLiterals();
        g.CopyFramePart("-->scan1");
        gen.Write("\t\t\t");
        if tab.ignored.Elements() > 0 { PutRange(tab.ignored) } else { gen.Write("false") }
        g.CopyFramePart("-->scan2")
        if (firstComment != nil) {
            gen.Write("\t\tif ")
            com = firstComment; comIdx = 0
            while com != nil {
                gen.Write(ChCond(com!.start[0]))
                gen.Write(" && Comment\(comIdx)()")
                if com!.next != nil { gen.Write(" ||") }
                com = com!.next; comIdx++
            }
            gen.Write(" { return NextToken();")
        }
        if hasCtxMoves { gen.WriteLine(); gen.Write("\t\tvar apx = 0") } /* pdt */
        g.CopyFramePart("-->scan3")
        for var state = firstState!.next; state != nil; state = state!.next {
            WriteState(state!)
        }
        g.CopyFramePart("")
        if !tab.nsName.isEmpty { gen.Write("}") }
        gen.close()
    }
    
} // end DFA

