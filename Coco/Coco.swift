/*-------------------------------------------------------------------------
    Compiler Generator Coco/R,
    Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
    extended by M. Loeberbauer & A. Woess, Univ. of Linz
    with improvements by Pat Terry, Rhodes University
    Swift port by Michael Griebling, 2015

    This program is free software; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2, or (at your option) any
    later version.

    This program is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.

    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc.,
    59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

    As an exception, it is allowed to write an extension of Coco/R that is
    used as a plugin in non-free software.

    If not otherwise stated, any source code generated by Coco/R (other than
    Coco/R itself) does not fall under the GNU General Public License.
-------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------
    Trace output options
    0 | A: prints the states of the scanner automaton
    1 | F: prints the First and Follow sets of all nonterminals
    2 | G: prints the syntax graph of the productions
    3 | I: traces the computation of the First sets
    4 | J: prints the sets associated with ANYs and synchronisation sets
    6 | S: prints the symbol table (terminals, nonterminals, pragmas)
    7 | X: prints a cross reference list of all syntax symbols
    8 | P: prints statistics about the Coco run

    Trace output can be switched on by the pragma
    $ { digit | letter }
    in the attributed grammar or as a command-line option
-------------------------------------------------------------------------*/

import Foundation
import ArgumentParser

struct Coco : ParsableCommand {
    
    static let configuration = CommandConfiguration(
        commandName: "Coco",
        abstract: "Coco/R is a compiler/compiler generator producing Swift source",
        version: "(2 July 2021)",
        shouldDisplay: true
    )
    
    @Argument(help: "File containing the attributed grammar to be parsed (e.g., grammar.atg)")
    var srcName : String
    
    @Option(name: [.short, .customLong("input", withSingleDash: true)],
            help: "Directory containing <src-name> input file and, by default, Scanner.frame and Parser.frame files")
    var inputDir = ""
    
    @Option(name: .customLong("namespace", withSingleDash: true), help: "Name defining the namespace to be parsed")
    var nsName = ""
    
    @Option(name: .customLong("frames", withSingleDash: true),
            help: "Directory containing the ATG frame files (possibly also Scanner.frame and Parser.frame files)")
    var frameDir = ""
    
    @Option(name: .customLong("trace", withSingleDash: true),
            help:
        """
        String whose characters can be:
           A  trace automaton
           F  list first/follow sets
           G  print syntax graph
           I  trace computation of first sets
           J  list ANY and SYNC sets
           P  print statistics
           S  list symbol table
           X  list cross reference table
         Output filename is 'trace.txt'
        """
    )
    var ddtString = ""
    
    @Option(name: [.short, .customLong("output", withSingleDash: true)], help: "<outputDir> directory for the files")
    var outputDir = ""
    
    @Flag(name: .customLong("lines", withSingleDash: true), help: "-lines emits output lines")
    var emitLines = false
    
    mutating func run() throws {
        print("\(Coco.configuration.commandName!)/R \(Coco.configuration.version)")
//        var srcName : NSString = ""
//        var nsName = ""
//        var frameDir = ""
//        var ddtString = ""
//        var traceFileName = ""
//        var outDir = ""
//        var emitLines = false
//        var i = 0
//        while i < arg.count {
//            if (arg[i] == "-namespace" && i < arg.count - 1) { i += 1; nsName = arg[i].trim() }
//            else if (arg[i] == "-frames" && i < arg.count - 1) { i += 1; frameDir = arg[i].trim() }
//            else if (arg[i] == "-trace" && i < arg.count - 1) { i += 1; ddtString = arg[i].trim() }
//            else if (arg[i] == "-o" && i < arg.count - 1) { i += 1; outDir = arg[i].trim() }
//            else if (arg[i] == "-lines") { emitLines = true }
//            else { srcName = arg[i] as NSString }
//            i += 1
//        }
//
//        if arg.count > 1 && srcName.length != 0 {
        var traceFileName = ""
        do {
            let srcDir = inputDir
            let scanner = Scanner(fileName: srcName)
            let parser = Parser(scanner: scanner)
            
            traceFileName = NSString(string: srcDir).appendingPathComponent("trace.txt")
            parser.trace = OutputStream(toFileAtPath: traceFileName, append: false)
            parser.trace?.open()
            parser.tab = Tab(parser: parser)
            parser.dfa = DFA(parser: parser)
            parser.pgen = ParserGen(parser: parser)
            
            parser.tab.srcName = srcName
            parser.tab.srcDir = srcDir
            parser.tab.nsName = nsName
            parser.tab.frameDir = frameDir
            parser.tab.outDir = !outputDir.isEmpty ? outputDir : srcDir
            parser.tab.emitLines = emitLines
            if !ddtString.isEmpty { parser.tab.SetDDT(ddtString) }
            
            parser.Parse()
            
            parser.trace?.close()
            let fs = FileManager.default
            let f = try fs.attributesOfItem(atPath: traceFileName)
            if f[.size] as? NSNumber == 0 { try fs.removeItem(atPath: traceFileName) }
            else { print("trace output is in " + traceFileName) }
            print("\(parser.errors.count) errors detected")
        } catch _ {
            print("-- could not open " + traceFileName)
            //            } catch (FatalError e) {
            //                print("-- " + e.Message)
        }
//        } else {
//            print("Usage: Coco Grammar.atg {{Option}}\n"
//                + "Options:\n"
//                + "  -namespace <namespaceName>\n"
//                + "  -frames    <frameFilesDirectory>\n"
//                + "  -trace     <traceString>\n"
//                + "  -o         <outputDirectory>\n"
//                + "  -lines\n"
//                + "Valid characters in the trace string:\n"
//                + "  A  trace automaton\n"
//                + "  F  list first/follow sets\n"
//                + "  G  print syntax graph\n"
//                + "  I  trace computation of first sets\n"
//                + "  J  list ANY and SYNC sets\n"
//                + "  P  print statistics\n"
//                + "  S  list symbol table\n"
//                + "  X  list cross reference table\n"
//                + "Scanner.frame and Parser.frame files needed in ATG directory\n"
//                + "or in a directory specified in the -frames option.")
//        }
    }
    
} // end Coco
