/*-------------------------------------------------------------------------
    Tab.swift -- Symbol Table Management
    Compiler Generator Coco/R,
    Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
    extended by M. Loeberbauer & A. Woess, Univ. of Linz
    with improvements by Pat Terry, Rhodes University
    Swift port by Michael Griebling, 2015

    This program is free software; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2, or (at your option) any
    later version.

    This program is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.

    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc.,
    59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

    As an exception, it is allowed to write an extension of Coco/R that is
    used as a plugin in non-free software.

    If not otherwise stated, any source code generated by Coco/R (other than
    Coco/R itself) does not fall under the GNU General Public License.
-------------------------------------------------------------------------*/

import Foundation

public struct Position {  // position of source code stretch (e.g. semantic action, resolver expressions)
	public let beg: Int      // start relative to the beginning of the file
	public let end: Int      // end of stretch
	public let col: Int      // column number of start position
	public let line: Int     // line number of start position
	
	public init(_ beg: Int, _ end: Int, _ col: Int, _ line: Int) {
		self.beg = beg; self.end = end; self.col = col; self.line = line
	}
    
    init() {
        self.init(0, 0, 0, 0)
    }
}

//=====================================================================
// Symbol
//=====================================================================

open class Symbol {
	
	// token kinds
	public static let fixedToken    = 0 // e.g. "a" ("b" | "c") (structure of literals)
	public static let classToken    = 1 // e.g. digit {digit}   (at least one char class)
	public static let litToken      = 2 // e.g. "while"
	public static let classLitToken = 3 // e.g. letter {letter} but without literals that have the same structure
	
	open var n = 0                // symbol number
	open var typ = 0              // t, nt, pr, unknown, rslv /* ML 29_11_2002 slv added */ /* AW slv --> rslv */
	open var name = ""            // symbol name
	open var graph: Node?         // nt: to first node of syntax graph
	open var tokenKind = 0        // t:  token kind (fixedToken, classToken, ...)
	open var deletable = false    // nt: true if nonterminal is deletable
	open var firstReady = false   // nt: true if terminal start symbols have already been computed
	open var first = BitArray()   // nt: terminal start symbols
	open var follow = BitArray()  // nt: terminal followers
	open var nts = BitArray()     // nt: Tab.nonterminals whose followers have to be added to this sym
	open var line = 0             // source text line number of item in this node
	open var attrPos: Position?   // nt: position of attributes in source text (or nil)
	open var semPos: Position?    // pr: pos of semantic action in source text (or nil)
	// nt: pos of local declarations in source text (or nil)
	
	public init(_ typ: Int, _ name: String, _ line: Int) {
		self.typ = typ; self.name = name; self.line = line
	}
    
    convenience init() {
        self.init(0, "", 0)
    }
}

//=====================================================================
// Node
//=====================================================================

open class Node {
	// constants for node kinds
	public static let t    =  1  // terminal symbol
	public static let pr   =  2  // pragma
	public static let nt   =  3  // nonterminal symbol
	public static let clas =  4  // character class
	public static let chr  =  5  // character
	public static let wt   =  6  // weak terminal symbol
	public static let any  =  7  //
	public static let eps  =  8  // empty
	public static let sync =  9  // synchronization symbol
	public static let sem  = 10  // semantic action: (. .)
	public static let alt  = 11  // alternative: |
	public static let iter = 12  // iteration: { }
	public static let opt  = 13  // option: [ ]
	public static let rslv = 14  // resolver expr
	
	public static let normalTrans  = 0		// transition codes
	public static let contextTrans = 1
	
	open var n = 0                // node number
	open var typ = 0              // t, nt, wt, chr, clas, any, eps, sem, sync, alt, iter, opt, rslv
	open var next:Node?     		// to successor node
	open var down:Node?     		// alt: to next alternative
	open var sub:Node?            // alt, iter, opt: to first node of substructure
	open var up = false 			// true: "next" leads to successor in enclosing structure
	open var sym: Symbol?   		// nt, t, wt: symbol represented by this node
	open var val = 0      		// chr:  ordinal character value
	// clas: index of character class
	open var code = 0     		// chr, clas: transition code
	open var set = BitArray()		// any, sync: the set represented by this node
	open var pos: Position?		// nt, t, wt: pos of actual attributes
	// sem:       pos of semantic action in source text
	// rslv:       pos of resolver in source text
	open var line = 0      		// source text line number of item in this node
	open var state: State?    	// DFA state corresponding to this node
	// (only used in DFA.ConvertToStates)
	
	public init(_ typ: Int, _ sym: Symbol?, _ line: Int) {
		self.typ = typ; self.sym = sym; self.line = line
	}
}

//=====================================================================
// Graph
//=====================================================================

open class Graph {
	open var l: Node?	// left end of graph = head
	open var r: Node?	// right end of graph = list of nodes to be linked to successor graph
	
	public init() {
		l = nil; r = nil
	}
	
	public init(left: Node?, right: Node?) {
		l = left; r = right
	}
	
	public init(_ p: Node?) {
		l = p; r = p
	}
}

//=====================================================================
// Sets
//=====================================================================

open class Sets {
	
	public static func Elements(_ s: BitArray) -> Int {
		var n = 0
		for item in s {
			if item { n += 1 }
		}
		return n
	}
	
	public static func Equals(_ a: BitArray, b: BitArray) -> Bool {
		let max = a.count
		for i in 0..<max {
			if a[i] != b[i] { return false }
		}
		return true
	}
	
	public static func Intersect(_ a: BitArray, b: BitArray) -> Bool { // a * b != {}
		let max = a.count
		for i in 0..<max {
			if a[i] && b[i] { return true }
		}
		return false
	}
	
	public static func Subtract(_ a: inout BitArray, b: BitArray) { // a = a - b
		let c = b.Clone()
		c.not()
        a.and(c)
	}
	
}

open class BitArray : Collection {
    
    var array: [Bool]
    
    // CollectionType protocol conformance
//    public typealias `Type` = Int
    open var startIndex: Int { return 0 }
    open var endIndex: Int { return array.count }
    
	public init(_ size: Int, value: Bool = false) {
        array = [Bool](repeating: value, count: size)
    }
    
    init() {
        array = [Bool]()
    }
    
    open var count: Int { return array.count }
    
    public func index(after i: Int) -> Int {
        if i >= startIndex && i < endIndex  {
            return i+1
        }
        return startIndex
    }
    
    open subscript (index: Int) -> Bool {
        get { return array[index] }
        set { array[index] = newValue }
    }
    
    open func and (_ b: BitArray) {
        let max = array.count
        for i in 0..<max {
            array[i] = array[i] && b[i]
        }
    }
    
    open func or (_ b: BitArray) {
        let max = array.count
        for i in 0..<max {
            array[i] = array[i] || b[i]
        }
    }
	
	open func Clone () -> BitArray {
		let copy = BitArray(count)
		copy.array = array
		return copy
	}
    
    open func not () {
        let max = array.count
        for i in 0..<max {
            array[i] = !array[i]
        }
    }
    
    open func equals (_ b: BitArray) -> Bool {
        return array == b.array
    }
    
    open func SetAll (_ value: Bool) {
        for i in 0..<array.count { array[i] = value }
    }
    
}

//=====================================================================
// CharClass
//=====================================================================

open class CharClass {
	open var n = 0            // class number
	open var name: String		// class name
	open var set: CharSet		// set representing the class
	
	public init(name: String, s: CharSet) {
		self.name = name; self.set = s
	}
}

extension OutputStream {
	
	func Write (_ s: String) {
		let data: Data = s.data(using: String.Encoding.utf8)!
		self.write((data as NSData).bytes.bindMemory(to: UInt8.self, capacity: data.count), maxLength: data.count)
	}
	
	func WriteLine (_ s: String = "") { Write(s + "\n") }
	
}

//=====================================================================
// Tab
//=====================================================================

open class Tab {
	open var semDeclPos = Position()          // position of global semantic declarations
	open var ignored = CharSet()              // characters ignored by the scanner
    open var ddt : [Bool]                     // debug and test switches
	open var gramSy : Symbol?                 // root nonterminal: filled by ATG
	open var eofSy = Symbol()                 // end of file symbol
	open var noSym = Symbol()                 // used in case of an error
	open var allSyncSets = BitArray()			// union of all synchronisation sets
	open var literals:[String: Symbol]        // symbols that are used as literals
	
	open var srcName = ""                     // name of the atg file (including path)
	open var srcDir = ""                      // directory path of the atg file
	open var nsName = ""                      // namespace for generated files
	open var frameDir = ""                    // directory containing the frame files
	open var outDir = ""                      // directory for generated files
	open var checkEOF = true                  // should coco generate a check for EOF at
	//   the end of Parser.Parse():
	open var emitLines=false                  // emit #line pragmas for semantic actions
	//   in the generated parser
	
	var visited = BitArray()					// mark list for graph traversals
	var curSy = Symbol()                        // current symbol in computation of sets
	
	var parser: Parser?                         // other Coco objects
	var trace : OutputStream?
	var errors: Errors?
	
	public init(parser: Parser?) {
        ddt = [Bool](repeating: false, count: 10)
		self.parser = parser
        if parser != nil {
            trace = parser!.trace
            errors = parser!.errors
        }
        literals = [:]
        dummyNode = Node(0, nil, 0)     // compiler complains about init without this
		dummyNode = NewNode(Node.eps, nil, 0)
		eofSy = NewSym(Node.t, "EOF", 0)
	}
    
    convenience init () {
        self.init(parser: nil)
    }
	
	//---------------------------------------------------------------------
	//  Symbol list management
	//---------------------------------------------------------------------
	
	open var terminals = [Symbol]()
	open var pragmas = [Symbol]()
	open var nonterminals = [Symbol]()
	
	let tKind = ["fixedToken", "classToken", "litToken", "classLitToken"]
	
	open func NewSym(_ typ: Int, _ name: String, _ line: Int) -> Symbol {
        var name = name
		if name.count == 2 && name[0] == "\"" {
			parser!.SemErr("empty token not allowed"); name = "???"
		}
		let sym = Symbol(typ, name, line)
		switch typ {
		case Node.t:  sym.n = terminals.count; terminals.append(sym)
		case Node.pr: pragmas.append(sym)
		case Node.nt: sym.n = nonterminals.count; nonterminals.append(sym)
        default: break
		}
		return sym
	}
	
	open func FindSym(_ name: String) -> Symbol? {
		for s in terminals {
			if s.name == name { return s }
		}
		for s in nonterminals {
			if s.name == name { return s }
		}
		return nil
	}
	
	func Num(_ p: Node?) -> Int {
		if let p = p { return p.n }
		else { return 0 }
	}
	
	func PrintSym(_ sym: Symbol) {
		trace?.Write("\(sym.n) \(Name(sym.name)) \(Tab.nTyp[sym.typ])")
		if (sym.attrPos == nil) { trace?.Write(" false ") } else { trace?.Write(" true  ") }
		if (sym.typ == Node.nt) {
			trace?.Write("\(Num(sym.graph))")
			if (sym.deletable) { trace?.Write(" true  ") } else { trace?.Write(" false ") }
		} else {
			trace?.Write("            ")
		}
		trace?.WriteLine("\(sym.line) \(tKind[sym.tokenKind])")
	}
	
	open func PrintSymbolTable() {
		trace?.WriteLine("Symbol Table:")
		trace?.WriteLine("------------"); trace?.WriteLine()
		trace?.WriteLine(" nr name          typ  hasAt graph  del    line tokenKind")
		for sym in terminals { PrintSym(sym) }
		for sym in pragmas { PrintSym(sym) }
		for sym in nonterminals { PrintSym(sym) }
		trace?.WriteLine()
		trace?.WriteLine("Literal Tokens:")
		trace?.WriteLine("--------------")
		for e in literals {
			trace?.WriteLine("_" + e.1.name + " = " + e.0 + ".")
		}
		trace?.WriteLine()
	}
	
	open func PrintSet(_ s: BitArray, indent: Int) {
		var col = indent
		var len: Int
		for sym in terminals {
			if s[sym.n] {
				len = sym.name.count
				if col + len >= 80 {
					trace?.WriteLine();
					if indent >= 1 {
						for _ in 1..<indent { trace?.Write(" ") }
					}
				}
				trace?.Write(sym.name + " ")
				col += len + 1
			}
		}
		if col == indent { trace?.Write("-- empty set --") }
		trace?.WriteLine()
	}
	
	//---------------------------------------------------------------------
	//  Syntax graph management
	//---------------------------------------------------------------------
	
	open var nodes = [Node]()
	public static let nTyp = ["    ", "t   ", "pr  ", "nt  ", "clas", "chr ", "wt  ", "any ", "eps ",
		"sync", "sem ", "alt ", "iter", "opt ", "rslv"]
	var dummyNode: Node
	
	open func NewNode(_ typ: Int, _ sym: Symbol?, _ line: Int) -> Node {
		let node = Node(typ, sym, line)
		node.n = nodes.count
		nodes.append(node)
		return node
	}
	
	open func NewNode(_ typ: Int, sub: Node) -> Node {
		let node = NewNode(typ, nil, 0)
		node.sub = sub
		return node
	}
	
	open func NewNode(_ typ: Int, val: Int, line: Int) -> Node {
		let node = NewNode(typ, nil, line)
		node.val = val
		return node
	}
	
	open func MakeFirstAlt(_ g: Graph) {
		g.l = NewNode(Node.alt, sub: g.l!); g.l!.line = g.l!.sub!.line
		g.r!.up = true
		g.l!.next = g.r
		g.r = g.l
	}
	
	// The result will be in g1
	open func MakeAlternative(_ g1: Graph, _ g2: Graph) {
		g2.l = NewNode(Node.alt, sub: g2.l!); g2.l!.line = g2.l!.sub!.line
		g2.l!.up = true
		g2.r!.up = true
		var p = g1.l; while p!.down != nil { p = p!.down }
		p!.down = g2.l
		p = g1.r; while p!.next != nil { p = p!.next }
		// append alternative to g1 end list
		p!.next = g2.l
		// append g2 end list to g1 end list
		g2.l!.next = g2.r
	}
	
	// The result will be in g1
	open func MakeSequence(_ g1: Graph, _ g2: Graph) {
		var p = g1.r!.next; g1.r!.next = g2.l // link head node
		while p != nil {  // link substructure
			let q = p!.next; p!.next = g2.l
			p = q
		}
		g1.r = g2.r
	}
	
	open func MakeIteration(_ g: Graph) {
		g.l = NewNode(Node.iter, sub: g.l!)
		g.r!.up = true
		var p = g.r
		g.r = g.l
		while p != nil {
			let q = p!.next; p!.next = g.l
			p = q
		}
	}
	
	open func MakeOption(_ g: Graph) {
		g.l = NewNode(Node.opt, sub: g.l!)
		g.r!.up = true
		g.l!.next = g.r
		g.r = g.l
	}
	
	open func Finish(_ g: Graph) {
		var p = g.r
		while p != nil {
			let q = p!.next; p!.next = nil
			p = q
		}
	}
	
	open func DeleteNodes() {
		nodes = [Node]()
		dummyNode = NewNode(Node.eps, nil, 0)
	}
	
	open func StrToGraph(_ str: String) -> Graph {
		let s = Unescape(str.substring(1, str.count-2))
		if s.count == 0 { parser!.SemErr("empty token not allowed") }
		let g = Graph()
		g.r = dummyNode
		for i in 0..<s.count {
			let p = NewNode(Node.chr, val: s[i].unicodeValue, line: 0)
			g.r!.next = p; g.r = p
		}
		g.l = dummyNode.next; dummyNode.next = nil
		return g
	}
	
	open func SetContextTrans(_ p: Node?) { // set transition code in the graph rooted at p
        var p = p
		while p != nil {
			if let np = p {
				if (np.typ == Node.chr || np.typ == Node.clas) {
					np.code = Node.contextTrans
				} else if (np.typ == Node.opt || np.typ == Node.iter) {
					SetContextTrans(np.sub)
				} else if (np.typ == Node.alt) {
					SetContextTrans(np.sub); SetContextTrans(np.down)
				}
				if np.up { break }
				p = np.next
			}
		}
	}
	
	//------------ graph deletability check -----------------
	
	public static func DelGraph(_ p: Node?) -> Bool {
		return p == nil || DelNode(p) && DelGraph(p!.next)
	}
	
	public static func DelSubGraph(_ p: Node?) -> Bool {
		return p == nil || DelNode(p) && (p!.up || DelSubGraph(p!.next));
	}
	
	public static func DelNode(_ p: Node?) -> Bool {
		guard let p = p else { return false }
		if (p.typ == Node.nt) { return p.sym!.deletable }
		else if (p.typ == Node.alt) { return DelSubGraph(p.sub) || p.down != nil && DelSubGraph(p.down) }
		else { return p.typ == Node.iter || p.typ == Node.opt || p.typ == Node.sem
			|| p.typ == Node.eps || p.typ == Node.rslv || p.typ == Node.sync }
	}
	
	//----------------- graph printing ----------------------
	
	func Ptr(_ p: Node?, up: Bool) -> String {
		let ptr = p == nil ? "0" : String(p!.n)
		return (up) ? "-" + ptr : ptr
	}
	
	func Pos(_ pos: Position?) -> String {
		if pos == nil { return "     " } else { return "\(pos!.beg)" }
	}
	
	open func Name(_ name: String) -> String {
		return name.padding(toLength: 12, withPad: " ", startingAt: 0)
	}
	
	open func PrintNodes() {
		trace?.WriteLine("Graph nodes:");
		trace?.WriteLine("----------------------------------------------------");
		trace?.WriteLine("   n type name          next  down   sub   pos  line");
		trace?.WriteLine("                               val  code");
		trace?.WriteLine("----------------------------------------------------");
		for p in nodes {
			trace?.Write("\(p.n) \(Tab.nTyp[p.typ]) ")
			if p.sym != nil {
				trace?.Write("\(Name(p.sym!.name)) ")
			} else if (p.typ == Node.clas) {
				let c = classes[p.val]
				trace?.Write("\(Name(c.name)) ")
			} else { trace?.Write("             ") }
			trace?.Write("\(Ptr(p.next, up: p.up)) ")
			switch p.typ {
			case Node.t, Node.nt, Node.wt:
				trace?.Write("             \(Pos(p.pos))")
			case Node.chr:
				trace?.Write("\(p.val) \(p.code)       ")
			case Node.clas:
				trace?.Write("      \(p.code)       ")
			case Node.alt, Node.iter, Node.opt:
				trace?.Write("\(Ptr(p.down, up: false)) \(Ptr(p.sub, up: false))       ")
			case Node.sem:
				trace?.Write("             \(Pos(p.pos))")
			case Node.eps, Node.any, Node.sync:
				trace?.Write("                  ")
            default: break
			}
			trace?.WriteLine("\(p.line)")
		}
		trace?.WriteLine()
	}
	
	
	//---------------------------------------------------------------------
	//  Character class management
	//---------------------------------------------------------------------
	
	open var classes = [CharClass]()
	open var dummyName : Character = "A"
	
	open func NewCharClass(_ name: String, _ s: CharSet) -> CharClass {
        var name = name
		if name == "#" { name = "#" + String(dummyName); dummyName += 1 }
		let c = CharClass(name: name, s: s)
		c.n = classes.count
		classes.append(c)
		return c
	}
	
	open func FindCharClass(_ name: String) -> CharClass? {
		for c in classes {
			if c.name == name { return c }
		}
		return nil
	}
	
	open func FindCharClass(_ s: CharSet) -> CharClass? {
		for c in classes {
			if s.Equals(c.set) { return c }
		}
		return nil
	}
	
	open func CharClassSet(_ i: Int) -> CharSet {
		return classes[i].set
	}
	
	//----------- character class printing
	
	func Ch(_ ch: Int) -> String {
        let lch = Character(ch)
		if lch < " " || ch >= 127 || lch == "\"" || lch == "\\" { return String(ch) }
		else { return "'\(lch)'" }
	}
	
    func WriteCharSet(_ s: CharSet) {
        var r = s.head
        while r != nil {
            if r!.from < r!.to { trace?.Write(Ch(r!.from) + ".." + Ch(r!.to) + " ") }
            else { trace?.Write(Ch(r!.from) + " ") }
            r = r!.next
        }
    }
	
	open func WriteCharClasses () {
		for c in classes {
			trace?.Write("\(c.name): ")
			WriteCharSet(c.set);
			trace?.WriteLine();
		}
		trace?.WriteLine();
	}
	
	
	//---------------------------------------------------------------------
	//  Symbol set computations
	//---------------------------------------------------------------------
	
	/* Computes the first set for the graph rooted at p */
	func First0(_ p: Node?, mark: BitArray) -> BitArray {
        var p = p
		let fs = BitArray(terminals.count)
		while p != nil && !mark[p!.n] {
			mark[p!.n] = true
			switch p!.typ {
			case Node.nt:
				if p!.sym!.firstReady { fs.or(p!.sym!.first) }
				else { fs.or(First0(p!.sym!.graph, mark: mark)) }
			case Node.t, Node.wt:
				fs[p!.sym!.n] = true
			case Node.any:
				fs.or(p!.set)
			case Node.alt:
				fs.or(First0(p!.sub, mark: mark))
				fs.or(First0(p!.down, mark: mark))
			case Node.iter, Node.opt:
				fs.or(First0(p!.sub, mark: mark))
            default: break
			}
			if !Tab.DelNode(p) { break }
			p = p!.next
		}
		return fs
	}
	
    open func First(_ p: Node?) -> BitArray {
        let fs = First0(p, mark: BitArray(nodes.count))
        if (ddt[3]) {
            trace?.WriteLine()
            if p != nil { trace?.WriteLine("First: node = \(p!.n)") }
            else { trace?.WriteLine("First: node = nil") }
            PrintSet(fs, indent: 0)
        }
        return fs
    }
	
	func CompFirstSets() {
		for sym in nonterminals {
            sym.first = BitArray(terminals.count)
			sym.firstReady = false
		}
		for sym in nonterminals {
			sym.first = First(sym.graph)
			sym.firstReady = true
		}
	}
	
    func CompFollow(_ p: Node?) {
        var p = p
        while let np = p , !visited[np.n] {
            visited[np.n] = true
            if np.typ == Node.nt {
                let s = First(np.next)
                np.sym!.follow.or(s)
                if Tab.DelGraph(np.next) {
                    np.sym!.nts[curSy.n] = true
                }
            } else if np.typ == Node.opt || np.typ == Node.iter {
                CompFollow(np.sub)
            } else if np.typ == Node.alt {
                CompFollow(np.sub); CompFollow(np.down);
            }
            p = np.next
        }
    }
	
    func Complete(_ sym: Symbol) {
		if !visited[sym.n] {
			visited[sym.n] = true
			for s in nonterminals {
				if (sym.nts[s.n]) {
					Complete(s);
					sym.follow.or(s.follow)
                    if sym === curSy { sym.nts[s.n] = false }
				}
			}
		}
	}
	
	func CompFollowSets() {
		for sym in nonterminals {
			sym.follow = BitArray(terminals.count)
			sym.nts = BitArray(nonterminals.count)
		}
		gramSy!.follow[eofSy.n] = true;
        visited = BitArray(nodes.count)
		for sym in nonterminals { // get direct successors of Tab.nonterminals
			curSy = sym;
			CompFollow(sym.graph)
		}
		for sym in nonterminals { // add indirect successors to followers
			visited = BitArray(nonterminals.count)
			curSy = sym
			Complete(sym)
		}
	}
	
    func LeadingAny(_ p: Node?) -> Node? {
        guard let p = p else { return nil }
        var a: Node? = nil
        if p.typ == Node.any { a = p }
        else if p.typ == Node.alt {
            a = LeadingAny(p.sub);
            if a == nil { a = LeadingAny(p.down) }
        }
        else if (p.typ == Node.opt || p.typ == Node.iter) { a = LeadingAny(p.sub) }
        if (a == nil && Tab.DelNode(p) && !p.up) { a = LeadingAny(p.next) }
        return a
    }
    
    func FindAS(_ p: Node?) { // find ANY sets
        var p = p
        var a: Node?
        while let np = p {
            if np.typ == Node.opt || np.typ == Node.iter {
                FindAS(np.sub);
                a = LeadingAny(np.sub);
                if a != nil { Sets.Subtract(&a!.set, b:First(np.next)) }
            } else if np.typ == Node.alt {
                let s1 = BitArray(terminals.count)
                var q: Node? = np
                while let qp = q {
                    FindAS(qp.sub);
                    a = LeadingAny(qp.sub)
                    if a != nil {
						let temp = First(qp.down)
						temp.or(s1)
                        Sets.Subtract(&a!.set, b:temp)
                    } else {
                        s1.or(First(qp.sub))
                    }
                    q = qp.down
                }
            }
            
            // Remove alternative terminals before ANY, in the following
            // examples a and b must be removed from the ANY set:
            // [a] ANY, or {a|b} ANY, or [a][b] ANY, or (a|) ANY, or
            // A = [a]. A ANY
            if Tab.DelNode(np) {
                a = LeadingAny(np.next)
                if (a != nil) {
                    let q = (np.typ == Node.nt) ? np.sym!.graph : np.sub
                    Sets.Subtract(&a!.set, b:First(q))
                }
            }
            
            if np.up { break }
            p = np.next
        }
    }
	
	func CompAnySets() {
        for sym in nonterminals { FindAS(sym.graph) }
	}
	
    open func Expected(_ p: Node?, curSy: Symbol) -> BitArray {
        let s = First(p)
        if Tab.DelGraph(p) { s.or(curSy.follow) }
        return s
    }
    
    // does not look behind resolvers; only called during LL(1) test and in CheckRes
    open func Expected0 (_ p: Node, curSy: Symbol) -> BitArray {
        if p.typ == Node.rslv { return BitArray(terminals.count) }
        else { return Expected(p, curSy: curSy) }
    }
	
	func CompSync(_ p: Node?) {
        var p = p
		while let pn = p , !visited[pn.n] {
			visited[pn.n] = true
			if (pn.typ == Node.sync) {
				let s = Expected(pn.next!, curSy: curSy)
				s[eofSy.n] = true
				allSyncSets.or(s)
				pn.set = s
			} else if pn.typ == Node.alt {
				CompSync(pn.sub); CompSync(pn.down)
			} else if pn.typ == Node.opt || pn.typ == Node.iter {
				CompSync(pn.sub)
			}
			p = pn.next
		}
	}
	
	func CompSyncSets() {
		allSyncSets = BitArray(terminals.count)
		allSyncSets[eofSy.n] = true
		visited = BitArray(nodes.count)
		for sym in nonterminals {
			curSy = sym
			CompSync(curSy.graph)
		}
	}
	
	open func SetupAnys() {
		for p in nodes {
			if p.typ == Node.any {
				p.set = BitArray(terminals.count, value:true)
				p.set[eofSy.n] = false
			}
		}
	}
	
	open func CompDeletableSymbols() {
		var changed: Bool
		repeat {
			changed = false
			for sym in nonterminals {
				if !sym.deletable && sym.graph != nil && Tab.DelGraph(sym.graph) {
					sym.deletable = true; changed = true
				}
			}
		} while changed
		for sym in nonterminals {
			if sym.deletable { errors!.Warning("  " + sym.name + " deletable") }
		}
	}
	
	open func RenumberPragmas() {
		var n = terminals.count
        for sym in pragmas { sym.n = n; n += 1 }
	}
	
	open func CompSymbolSets() {
		CompDeletableSymbols();
		CompFirstSets()
		CompAnySets()
		CompFollowSets()
		CompSyncSets()
		if ddt[1] {
			trace?.WriteLine()
			trace?.WriteLine("First & follow symbols:")
			trace?.WriteLine("----------------------"); trace?.WriteLine()
			for sym in nonterminals {
				trace?.WriteLine(sym.name)
				trace?.Write("first:   "); PrintSet(sym.first, indent: 10)
				trace?.Write("follow:  "); PrintSet(sym.follow, indent: 10)
				trace?.WriteLine()
			}
		}
		if ddt[4] {
			trace?.WriteLine()
			trace?.WriteLine("ANY and SYNC sets:")
			trace?.WriteLine("-----------------")
			for p in nodes {
				if p.typ == Node.any || p.typ == Node.sync {
					trace?.Write("\(p.n) \(Tab.nTyp[p.typ]): ")
					PrintSet(p.set, indent: 11)
				}
			}
		}
	}
	
	//---------------------------------------------------------------------
	//  String handling
	//---------------------------------------------------------------------
	
	func Hex2Char(_ s: String) -> Character {
		var val = 0
		for i in 0..<s.count {
			let ch = s[i]
			if "0" <= ch && ch <= "9" { val = 16 * val + (ch - Character("0")) }
			else if "a" <= ch && ch <= "f" { val = 16 * val + (10 + (ch - Character("a"))) }
			else if "A" <= ch && ch <= "F" { val = 16 * val + (10 + (ch - Character("A"))) }
			else { parser?.SemErr("bad escape sequence in string or character") }
		}
		if val > Int(UniChar.max) { /* pdt */
			parser?.SemErr("bad escape sequence in string or character")
		}
		return Character(val)
	}
	
	func Char2Hex(_ ch: Character) -> String {
		let s = String(format: "\\u%04X", ch.unicodeValue)
		return s
	}
	
	open func Unescape (_ s: String) -> String {
		/* replaces escape sequences in s by their Unicode values. */
		var buf = ""
		var i = 0
		while i < s.count {
			if s[i] == "\\" {
				switch s[i+1] {
				case "\\": buf += "\\"; i += 2
				case "'":  buf += "'"; i += 2
				case "\"": buf += "\""; i += 2
				case "r": buf += "\r"; i += 2
				case "n": buf += "\n"; i += 2
				case "t": buf += "\t"; i += 2
				case "0": buf += "\0"; i += 2
				case "a": buf += "\u{07}"; i += 2
				case "b": buf += "\u{08}"; i += 2
				case "f": buf += "\u{0c}"; i += 2
				case "v": buf += "\u{0b}"; i += 2
				case "u", "x":
					if i+6 <= s.count {
						let sn : NSString = s as NSString
						buf.append(Hex2Char(sn.substring(with: NSMakeRange(i+2, 4)))); i += 6
					} else {
						parser?.SemErr("bad escape sequence in string or character"); i = s.count
					}
				default: parser?.SemErr("bad escape sequence in string or character"); i += 2
				}
			} else {
				buf.append(s[i])
				i += 1
			}
		}
		return buf
	}
	
	open func Escape (_ s: String) -> String {
		var buf = ""
		for ch in s {
			switch(ch) {
			case "\\": buf += "\\\\"
			case "'": buf += "\\'"
			case "\"": buf += "\\\""
			case "\t": buf += "\\t"
			case "\r": buf += "\\r"
			case "\n": buf += "\\n"
			default:
				if ch < " " || ch > "\u{7f}" { buf += Char2Hex(ch) }
				else { buf.append(ch) }
			}
		}
		return buf
	}

	//---------------------------------------------------------------------
	//  Grammar checks
	//---------------------------------------------------------------------
	
	open func GrammarOk() -> Bool {
		let ok = NtsComplete() && AllNtReached() && NoCircularProductions() && AllNtToTerm()
		if ok { CheckResolvers(); CheckLL1() }
		return ok
	}

	//--------------- check for circular productions ----------------------
	
    class CNode {	// node of list for finding circular productions
		var left: Symbol?
		var right: Symbol?
		
		init (l: Symbol?, r: Symbol?) {
			left = l; right = r
		}

	}

	func GetSingles(_ p: Node?, singles: inout [Symbol]) {
		guard let np = p else { return }  // end of graph
		if np.typ == Node.nt {
			if np.up || Tab.DelGraph(np.next) { singles.append(np.sym!) }
		} else if np.typ == Node.alt || np.typ == Node.iter || np.typ == Node.opt {
			if np.up || Tab.DelGraph(np.next) {
				GetSingles(np.sub, singles: &singles)
				if np.typ == Node.alt { GetSingles(np.down, singles: &singles) }
			}
		}
		if !np.up && Tab.DelNode(np) { GetSingles(np.next, singles: &singles) }
	}
	
	open func NoCircularProductions() -> Bool {
		var list = [CNode]()
		for sym in nonterminals {
			var singles = [Symbol]()
			GetSingles(sym.graph, singles: &singles) // get nonterminals s such that sym-->s
			for s in singles { list.append(CNode(l: sym, r: s)) }
		}
		var onLeftSide: Bool
		var onRightSide: Bool
		var changed: Bool
		repeat {
			changed = false
            var i = 0
			while i<list.count {
				let n = list[i]
				onLeftSide = false; onRightSide = false
				for m in list {
					if n.left === m.right { onRightSide = true }
					if n.right === m.left { onLeftSide = true }
				}
				if !onLeftSide || !onRightSide {
                    list = list.filter() { $0 !== n }  // remove n from list
					i -= 1; changed = true
				}
                i += 1
			}
		} while changed
		var ok = true
		for n in list {
			ok = false
			errors?.SemErr("  " + n.left!.name + " --> " + n.right!.name)
		}
		return ok
	}

	//--------------- check for LL(1) errors ----------------------
	
	func LL1Error(_ cond: Int, sym: Symbol?) {
		var s = "  LL1 warning in " + curSy.name + ": ";
		if sym != nil { s += sym!.name + " is " }
		switch (cond) {
		case 1: s += "start of several alternatives"
		case 2: s += "start & successor of deletable structure"
		case 3: s += "an ANY node that matches no symbol"
		case 4: s += "contents of [...] or {...} must not be deletable"
		default: break
		}
		errors?.Warning(s)
	}
	
	func CheckOverlap(_ s1: BitArray, s2: BitArray, cond: Int) {
		for sym in terminals {
			if s1[sym.n] && s2[sym.n] { LL1Error(cond, sym: sym) }
		}
	}

	func CheckAlts(_ p: Node?) {
        var p = p
		var s1: BitArray
		var s2: BitArray
		while let np = p {
			if np.typ == Node.alt {
				var q: Node? = np
				s1 = BitArray(terminals.count)
				while let nq = q { // for all alternatives
					s2 = Expected0(nq.sub!, curSy: curSy)
					CheckOverlap(s1, s2: s2, cond: 1)
					s1.or(s2)
					CheckAlts(nq.sub)
					q = nq.down
				}
			} else if (np.typ == Node.opt || np.typ == Node.iter) {
				if Tab.DelSubGraph(np.sub) { LL1Error(4, sym: nil) } // e.g. [[...]]
				else {
					s1 = Expected0(np.sub!, curSy: curSy);
					s2 = Expected(np.next, curSy: curSy);
					CheckOverlap(s1, s2: s2, cond: 2);
				}
				CheckAlts(np.sub)
			} else if (np.typ == Node.any) {
				if Sets.Elements(np.set) == 0 { LL1Error(3, sym: nil) }
				// e.g. {ANY} ANY or [ANY] ANY or ( ANY | ANY )
			}
			if np.up { break }
			p = np.next
		}
	}

	open func CheckLL1() {
		for sym in nonterminals {
			curSy = sym
			CheckAlts(curSy.graph)
		}
	}

	//------------- check if resolvers are legal  --------------------
	
	func ResErr(_ p:Node, msg: String) {
		errors?.Warning(p.line, col: p.pos!.col, s: msg)
	}

	func CheckRes(_ p: Node?, rslvAllowed: Bool) {
        var p = p
        var rslvAllowed = rslvAllowed
		while let np = p {
			switch np.typ {
			case Node.alt:
				let expected = BitArray(terminals.count)
                var q: Node? = np
				while q != nil {
					expected.or(Expected0(q!.sub!, curSy: curSy))
                    q = q!.down
				}
				let soFar = BitArray(terminals.count)
                q = np
				while q != nil {
					if q!.sub!.typ == Node.rslv {
						let fs = Expected(q!.sub!.next!, curSy: curSy)
						if Sets.Intersect(fs, b: soFar) {
							ResErr(q!.sub!, msg: "Warning: Resolver will never be evaluated. " +
								"Place it at previous conflicting alternative.")
						}
						if (!Sets.Intersect(fs, b: expected)) {
							ResErr(q!.sub!, msg: "Warning: Misplaced resolver: no LL(1) conflict.")
						}
					} else { soFar.or(Expected(q!.sub!, curSy: curSy)) }
					CheckRes(q!.sub!, rslvAllowed: true)
                    q = q!.down
				}
			case Node.iter, Node.opt:
				if np.sub!.typ == Node.rslv {
					let fs = First(np.sub!.next)
					let fsNext = Expected(np.next!, curSy: curSy)
					if !Sets.Intersect(fs, b: fsNext) {
						ResErr(np.sub!, msg: "Warning: Misplaced resolver: no LL(1) conflict.")
					}
				}
				CheckRes(np.sub, rslvAllowed: true)
			case Node.rslv:
				if (!rslvAllowed) {
					ResErr(np, msg: "Warning: Misplaced resolver: no alternative.")
				}
            default: break
			}
			if np.up { break }
			p = np.next
			rslvAllowed = false
		}
	}
	
	open func CheckResolvers() {
		for sym in nonterminals {
			curSy = sym
			CheckRes(curSy.graph, rslvAllowed: false)
		}
	}
	
	//------------- check if every nts has a production --------------------
	
	open func NtsComplete() -> Bool {
		var complete = true
		for sym in nonterminals {
			if sym.graph == nil {
				complete = false
				errors?.SemErr("  No production for " + sym.name)
			}
		}
		return complete
	}

	//-------------- check if every nts can be reached  -----------------
	
	func MarkReachedNts(_ p: Node?) {
        var p = p
		while let np = p {
			if np.typ == Node.nt && !visited[np.sym!.n] { // new nt reached
				visited[np.sym!.n] = true
				MarkReachedNts(np.sym!.graph)
			} else if np.typ == Node.alt || np.typ == Node.iter || np.typ == Node.opt {
				MarkReachedNts(np.sub)
				if np.typ == Node.alt { MarkReachedNts(np.down) }
			}
			if np.up { break }
			p = np.next
		}
	}

	open func AllNtReached() -> Bool {
		var ok = true
		visited = BitArray(nonterminals.count)
		visited[gramSy!.n] = true
		MarkReachedNts(gramSy!.graph)
		for sym in nonterminals {
			if !visited[sym.n] {
				ok = false
				errors?.Warning("  " + sym.name + " cannot be reached")
			}
		}
		return ok;
	}

	//--------- check if every nts can be derived to terminals  ------------
	
	func IsTerm(_ p: Node?, mark: BitArray) -> Bool { // true if graph can be derived to terminals
        var p = p
		while let np = p {
            if (np.typ == Node.nt && !mark[np.sym!.n]) { return false }
			if (np.typ == Node.alt && !IsTerm(np.sub, mark: mark)
                && (np.down == nil || !IsTerm(np.down, mark: mark))) { return false }
            if np.up { break }
			p = np.next
		}
		return true;
	}
	
    open func AllNtToTerm() -> Bool {
        var changed = false
        var ok = true
        let mark = BitArray(nonterminals.count)
        // a nonterminal is marked if it can be derived to terminal symbols
        repeat {
            changed = false;
            for sym in nonterminals {
                if (!mark[sym.n] && IsTerm(sym.graph, mark:mark)) {
                    mark[sym.n] = true; changed = true
                }
            }
        } while changed
        for sym in nonterminals {
            if (!mark[sym.n]) {
                ok = false
                errors?.SemErr("  " + sym.name + " cannot be derived to terminals")
            }
        }
        return ok
    }

	//---------------------------------------------------------------------
	//  Cross reference list
	//---------------------------------------------------------------------
	
	open func XRef() {
        var xref = [String:NSMutableArray]()  // NSMutableArray allows an updatable object link to be used
        var list : NSMutableArray?
        
		// collect lines where symbols have been defined
		for sym in nonterminals {
            list = xref[sym.name]
            if list == nil { list = NSMutableArray(); xref[sym.name] = list }
			list?.add(-sym.line)
		}
        
		// collect lines where symbols have been referenced
		for n in nodes {
			if n.typ == Node.t || n.typ == Node.wt || n.typ == Node.nt {
                let name = n.sym!.name
                list = xref[name]
                if list == nil { list = NSMutableArray(); xref[name] = list }
                list?.add(n.line)
			}
		}
        
		// print cross reference list
		trace?.WriteLine()
		trace?.WriteLine("Cross reference list:")
		trace?.WriteLine("--------------------"); trace?.WriteLine()
        for (name, list) in xref.sorted(by: { $0.0 < $1.0 }) {
			trace?.Write("  \(Name(name))")
			var col = 14
			for line in list {
				if col + 5 > 80 {
					trace?.WriteLine()
                    for _ in 1...14 { trace?.Write(" ") }
				}
				trace?.Write("\(line)  "); col += 5
			}
			trace?.WriteLine()
		}
		trace?.WriteLine(); trace?.WriteLine()
	}
	
    open func SetDDT(_ s: String) {
        for ch in s.uppercased() {
            if "0" <= ch && ch <= "9" {
                ddt[ch - "0"] = true
            } else {
                switch (ch) {
                case "A" : ddt[0] = true // trace automaton
                case "F" : ddt[1] = true // list first/follow sets
                case "G" : ddt[2] = true // print syntax graph
                case "I" : ddt[3] = true // trace computation of first sets
                case "J" : ddt[4] = true // print ANY and SYNC sets
                case "P" : ddt[8] = true // print statistics
                case "S" : ddt[6] = true // list symbol table
                case "X" : ddt[7] = true // list cross reference table
                default : break
                }
            }
        }
    }
	
    open func SetOption(_ s:String) {
		let option = s.components(separatedBy: "=")   // Split(new char[] {"="}, 2);
		let name = option[0]
        let value = option[1]
		if "$namespace" == name {
            if nsName.isEmpty { nsName = value }
		} else if "$checkEOF" == name {
			checkEOF = "true" == value
		}
	}

} // end Tab


